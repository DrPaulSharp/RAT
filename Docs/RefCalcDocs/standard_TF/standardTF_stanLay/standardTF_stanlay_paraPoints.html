<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of standardTF_stanlay_paraPoints</title>
  <meta name="keywords" content="standardTF_stanlay_paraPoints">
  <meta name="description" content="Standard Layers calculation paralelised over the inner loop">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- ../menu.html standard_TF --><!-- menu.html standardTF_stanLay -->
<h1>standardTF_stanlay_paraPoints
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>Standard Layers calculation paralelised over the inner loop</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function [outSsubs,backgs,qshifts,sfs,nbas,nbss,resols,chis,reflectivity,Simulation,shifted_data,layerSlds,sldProfiles,allLayers,allRoughs] = standardTF_stanlay_paraPoints(problemDef,problemDef_cells,problemDef_limits,controls) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Standard Layers calculation paralelised over the inner loop
 This is the main reflectivity calculation of the standard layers
 calculation type. It extracts the required paramters for the contrasts
 from the input arrays, then passes the main calculation to
 'standardLayersCore', which carries out the calculation iteslf. 
 The core calculation is common for both standard and custom layers.</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../common/backSorts/backSort.html" class="code" title="function [backg,qshift,sf,nba,nbs,resol] = backSort(cBacks,cShifts,cScales,cNbas,cNbss,cRes,backs,shifts,sf,nba,nbs,res)">backSort</a>	Distributes the background and shift values among the different contrasts.</li><li><a href="../../common/groupLayers/allocateLayersForContrast.html" class="code" title="function     thisContrastLayers = allocateLayersForContrast(contrastLayers,outParameterisedLayers)">allocateLayersForContrast</a>	Decide which layers are needed for a particular contrast</li><li><a href="../../common/groupLayers/allocateParamsToLayers.html" class="code" title="function outLayers = allocateParamsToLayers(params, layersDetails);">allocateParamsToLayers</a>	Allocates parameters from the parameter array to the correct layers</li><li><a href="../../standard_TF/standardTF_layers_core.html" class="code" title="function [sldProfile,reflect,Simul,shifted_dat,layerSld,chiSq,ssubs] =standardTF_layers_core(contrastLayers, rough,geometry, nba, nbs, resample, calcSld, sf, qshift,dataPresent, data, dataLimits, simLimits, repeatLayers,background,resol,backsType,params,paralellPoints)">standardTF_layers_core</a>	This is the main reflectivity calculation for all Layers models in the</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../standard_TF/standardTF_stanLay_reflectivityCalculation.html" class="code" title="function [problem,reflectivity,Simulation,shifted_data,layerSlds,sldProfiles,allLayers] = standardTF_stanLay_reflectivityCalculation(problemDef,problemDef_cells,problemDef_limits,controls)">standardTF_stanLay_reflectivityCalculation</a>	Standard layers reflectivity calculation for standardTF</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 
0002 <a name="_sub0" href="#_subfunctions" class="code">function [outSsubs,backgs,qshifts,sfs,nbas,nbss,resols,chis,reflectivity,</a><span class="keyword">...</span>
0003     Simulation,shifted_data,layerSlds,sldProfiles,allLayers,<span class="keyword">...</span>
0004     allRoughs] = standardTF_stanlay_paraPoints(problemDef,problemDef_cells,<span class="keyword">...</span>
0005     problemDef_limits,controls)
0006 
0007 <span class="comment">% Standard Layers calculation paralelised over the inner loop</span>
0008 <span class="comment">% This is the main reflectivity calculation of the standard layers</span>
0009 <span class="comment">% calculation type. It extracts the required paramters for the contrasts</span>
0010 <span class="comment">% from the input arrays, then passes the main calculation to</span>
0011 <span class="comment">% 'standardLayersCore', which carries out the calculation iteslf.</span>
0012 <span class="comment">% The core calculation is common for both standard and custom layers.</span>
0013 
0014 
0015 <span class="comment">% Extract individual cell arrays</span>
0016 [repeatLayers,<span class="keyword">...</span>
0017  allData,<span class="keyword">...</span>
0018  dataLimits,<span class="keyword">...</span>
0019  simLimits,<span class="keyword">...</span>
0020  contrastLayers,<span class="keyword">...</span>
0021  layersDetails] = RAT_parse_cells(problemDef_cells);
0022 
0023 <span class="comment">% Extract individual parameters from problemDef</span>
0024 [numberOfContrasts, geometry, cBacks, cShifts, cScales, cNbas, cNbss,<span class="keyword">...</span>
0025 cRes, backs, shifts, sf, nba, nbs, res, dataPresent, nParams, params,<span class="keyword">...</span>
0026 numberOfLayers, resample, backsType] =  extractProblemParams(problemDef);
0027 
0028 calcSld = controls.calcSld;     
0029          
0030 <span class="comment">% Allocate the memory for the output arrays before the main loop</span>
0031 <span class="comment">%   --- Begin memory allocation ---</span>
0032 backgs = zeros(numberOfContrasts,1);
0033 qshifts = zeros(numberOfContrasts,1);
0034 sfs = zeros(numberOfContrasts,1);
0035 nbas = zeros(numberOfContrasts,1);
0036 nbss = zeros(numberOfContrasts,1);
0037 resols = zeros(numberOfContrasts,1);
0038 allRoughs = zeros(numberOfContrasts,1);
0039 outSsubs = zeros(numberOfContrasts,1);
0040 chis =  zeros(numberOfContrasts,1);
0041 layerSlds = cell(numberOfContrasts,1);
0042 sldProfiles = cell(numberOfContrasts,1);
0043 shifted_data = cell(numberOfContrasts,1);
0044 
0045 reflectivity = cell(numberOfContrasts,1);
0046 <span class="keyword">for</span> i = 1:numberOfContrasts
0047     reflectivity{i} = [1 1 ; 1 1];
0048 <span class="keyword">end</span>
0049 
0050 Simulation = cell(numberOfContrasts,1);
0051 <span class="keyword">for</span> i = 1:numberOfContrasts
0052     Simulation{i} = [1 1 ; 1 1];
0053 <span class="keyword">end</span>
0054 
0055 allLayers = cell(numberOfContrasts,1);
0056 <span class="keyword">for</span> i = 1:numberOfContrasts
0057     allLayers{i} = [1 ; 1];
0058 <span class="keyword">end</span>
0059 <span class="comment">% ---end memory allocation---</span>
0060 
0061 
0062 <span class="comment">% First we need to allocate the absolute values of the input</span>
0063 <span class="comment">% parameters to all the layers in the layers list. This only needs</span>
0064 <span class="comment">% to be done once, and so is done outside the contrasts loop</span>
0065 outParameterisedLayers = <a href="../../common/groupLayers/allocateParamsToLayers.html" class="code" title="function outLayers = allocateParamsToLayers(params, layersDetails);">allocateParamsToLayers</a>(params, layersDetails);
0066 
0067 <span class="comment">% Single Loop over all the contrasts</span>
0068 <span class="keyword">for</span> i = 1:numberOfContrasts
0069     
0070     <span class="comment">% Extract the relevant parameter values for this contrast</span>
0071     <span class="comment">% from the input arrays.</span>
0072     <span class="comment">% First need to decide which values of the backrounds, scalefactors</span>
0073     <span class="comment">% data shifts and bulk contrasts are associated with this contrast</span>
0074     [thisBackground,thisQshift,thisSf,thisNba,thisNbs,thisResol] = <a href="../../common/backSorts/backSort.html" class="code" title="function [backg,qshift,sf,nba,nbs,resol] = backSort(cBacks,cShifts,cScales,cNbas,cNbss,cRes,backs,shifts,sf,nba,nbs,res)">backSort</a>(cBacks(i),cShifts(i),cScales(i),cNbas(i),cNbss(i),cRes(i),backs,shifts,sf,nba,nbs,res);
0075     
0076     <span class="comment">% Also need to determine which layers from the overall layers list</span>
0077     <span class="comment">% are required for this contrast, and put them in the correct order</span>
0078     <span class="comment">% according to geometry</span>
0079     thisContrastLayers = <a href="../../common/groupLayers/allocateLayersForContrast.html" class="code" title="function     thisContrastLayers = allocateLayersForContrast(contrastLayers,outParameterisedLayers)">allocateLayersForContrast</a>(contrastLayers{i},outParameterisedLayers);
0080     
0081     <span class="comment">% For the other parameters, we extract the correct ones from the input</span>
0082     <span class="comment">% arrays</span>
0083     thisRough = params(1);      <span class="comment">% Substrate roughness is always first parameter for standard layers</span>
0084     thisRepeatLayers = repeatLayers{i};
0085     thisResample = resample(i);
0086     thisCalcSld = calcSld;
0087     thisData = allData{i};
0088     thisDataPresent = dataPresent(i);
0089     thisDataLimits = dataLimits{i};
0090     thisSimLimits = simLimits{i};
0091     thisBacksType = backsType(i);
0092     
0093     <span class="comment">% Now call the core standardTF_stanlay reflectivity calculation</span>
0094     <span class="comment">% In this case we parallelise over points.</span>
0095     paralellPoints = <span class="string">'points'</span>;
0096     
0097     <span class="comment">% Call the calculation</span>
0098     [sldProfile,reflect,Simul,shifted_dat,layerSld,<span class="keyword">...</span>
0099         thisChiSquared,thisSsubs] = <a href="../../standard_TF/standardTF_layers_core.html" class="code" title="function [sldProfile,reflect,Simul,shifted_dat,layerSld,chiSq,ssubs] =standardTF_layers_core(contrastLayers, rough,geometry, nba, nbs, resample, calcSld, sf, qshift,dataPresent, data, dataLimits, simLimits, repeatLayers,background,resol,backsType,params,paralellPoints)">standardTF_layers_core</a>(thisContrastLayers, thisRough, <span class="keyword">...</span>
0100     geometry, thisNba, thisNbs, thisResample, thisCalcSld, thisSf, thisQshift,<span class="keyword">...</span>
0101     thisDataPresent, thisData, thisDataLimits, thisSimLimits, thisRepeatLayers,<span class="keyword">...</span>
0102     thisBackground,thisResol,thisBacksType,nParams,paralellPoints);
0103    
0104     <span class="comment">% Store returned values for this contrast in the output arrays.</span>
0105     <span class="comment">% As well as the calculated profiles, we also store a record of</span>
0106     <span class="comment">% the other values (background, scalefactors etc) for each contrast</span>
0107     <span class="comment">% for future use.</span>
0108     outSsubs(i) = thisSsubs;
0109     sldProfiles{i} = sldProfile;
0110     reflectivity{i} = reflect;
0111     Simulation{i} = Simul;
0112     shifted_data{i} = shifted_dat;
0113     layerSlds{i} = layerSld;
0114     chis(i) = thisChiSquared;
0115     backgs(i) = thisBackground;
0116     qshifts(i) = thisQshift;
0117     sfs(i) = thisSf;
0118     nbas(i) = thisNba;
0119     nbss(i) = thisNbs;
0120     resols(i) = thisResol;
0121     allRoughs(i) = thisRough;
0122 <span class="keyword">end</span>
0123 
0124 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Fri 25-Jun-2021 13:32:14 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>