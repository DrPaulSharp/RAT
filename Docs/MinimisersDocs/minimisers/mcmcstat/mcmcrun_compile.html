<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of mcmcrun_compile</title>
  <meta name="keywords" content="mcmcrun_compile">
  <meta name="description" content="MCMCRUN Metropolis-Hastings MCMC simulation for nonlinear Gaussian models">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- ../menu.html minimisers --><!-- menu.html mcmcstat -->
<h1>mcmcrun_compile
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>MCMCRUN Metropolis-Hastings MCMC simulation for nonlinear Gaussian models</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function [results,chain,s2chain,sschain, hchain]=mcmcrun_compile(model,data,problem,params,options,res) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment">MCMCRUN Metropolis-Hastings MCMC simulation for nonlinear Gaussian models
 properties:
  multiple y-columns, sigma2-sampling, adaptation,
  Gaussian prior, parameter limits, delayed rejection, dram

 [RESULTS,CHAIN,S2CHAIN,SSCHAIN] = MCMCRUN(MODEL,DATA,PARAMS,OPTIONS)
 MODEL   model options structure
    model.ssfun    -2*log(likelihood) function
    model.priorfun -2*log(pior) prior function
    model.sigma2   initial error variance
    model.N        total number of observations
    model.S20      prior for sigma2
    model.N0       prior accuracy for S20
    model.nbatch   number of datasets

     sum-of-squares function 'model.ssfun' is called as
     ss = ssfun(par,data) or
     ss = ssfun(par,data,local)
     instead of ssfun, you can use model.modelfun as
     ymodel = modelfun(data{ibatch},theta_local)

     prior function is called as priorfun(par,pri_mu,pri_sig) it
     defaults to Gaussian prior with infinite variance

     The parameter sigma2 gives the variances of measured components,
     one for each. If the default options.updatesigma = 0 (see below) is
     used, sigma2 is fixed, as typically estimated from the fitted residuals.
     If opions.updatesigma = 1, the variances are sampled as conjugate priors
     specified by the parameters S20 and N0 of the inverse gamma
     distribution, with the 'noninformative' defaults
          S20 = sigma2   (as given by the user)
          N0  = 1
     Larger values of N0 limit the samples closer to S20
     (see,e.g., A.Gelman et all:
     Bayesian Data Analysis, http://www.stat.columbia.edu/~gelman/book/)

 DATA the data, passed directly to ssfun. The structure of DATA is given
      by the user. Typically, it contains the measurements

      data.xdata
      data.ydata,

      A possible 'time' variable must be given in the first column of
      xdata. Note that only data.xdata is needed for model simulations.
      In addition, DATA may include any user defined structure needed by
      |modelfun| or |ssfun|

 PARAMS  theta structure
   {  {'par1',initial, min, max, pri_mu, pri_sig, targetflag, localflag}
      {'par2',initial, min, max, pri_mu, pri_sig, targetflag, localflag}
      ... }

   'name' and initial are compulsary, other values default to
   {'name', initial,  -Inf, Inf,  NaN, Inf,  1,  0}

 OPTIONS mcmc run options
    options.nsimu            number of simulations
    options.qcov             proposal covariance
    options.method           'dram','am','dr', 'ram' or 'mh'
    options.adaptint         interval for adaptation, if 'dram' or 'am' used
                             DEFAULT adaptint = 100
    options.drscale          scaling for proposal stages of dr
                             DEFAULT 3 stages, drscale = [5 4 3]
    options.updatesigma      update error variance. Sigma2 sampled with updatesigma=1
                             DEFAULT updatesigma=0
    options.verbosity        level of information printed
    options.waitbar          use graphical waitbar?
    options.burnintime       burn in before adaptation starts

 Output:
  RESULTS   structure that contains results and information about
            the simulations
  CHAIN, S2CHAIN, SSCHAIN
           parameter, sigma2 and sum-of-squares chains</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="addbin.html" class="code" title="function status=addbin(filename,x)">addbin</a>	ADDBIN add columns to a V4 matfile</li><li><a href="covupd.html" class="code" title="function [xcov,xmean,wsum,R]=covupd(x,w,oldcov,oldmean,oldwsum,oldR)">covupd</a>	COVUPD covariance update</li><li><a href="gammar.html" class="code" title="function y=gammar(m,n,a,b)">gammar</a>	GAMMAR random deviates from gamma distribution</li><li><a href="geweke.html" class="code" title="function [z,p]=geweke(chain,a,b)">geweke</a>	GEWEKE Geweke's MCMC convergence diagnostic</li><li><a href="iact.html" class="code" title="function [tau,m] = iact(dati)">iact</a>	IACT estimates the integrated autocorrelation time</li><li><a href="../../minimisers/mcmcstat/private/checkoptions.html" class="code" title="function [yesno,bad] = checkoptions(options,goodopts)">checkoptions</a>	CHECKOPIONS check option structure</li><li><a href="../../minimisers/mcmcstat/private/getN.html" class="code" title="function n=getN(data)">getN</a>	try to guess number of data lines of data for mcmcrun</li><li><a href="../../minimisers/mcmcstat/private/getnbatch.html" class="code" title="function n=getnbatch(data)">getnbatch</a>	try to guess number of batches of mcmc data</li><li><a href="../../minimisers/mcmcstat/private/getpar.html" class="code" title="function y=getpar(options,par,default)">getpar</a>	GETPAR get parameter value from a struct</li><li><a href="reflectivity_fitModel.html" class="code" title="function ss = reflectivity_fitModel(theta,data,problem)">reflectivity_fitModel</a>	Sum of squares function used in the calculation</li><li><a href="res2par.html" class="code" title="function params = res2par(res,params,loc)">res2par</a>	RES2PAR utility for mcmc tbx</li><li><a href="rldiag.html" class="code" title="function y=rldiag(chain,q,r,s,e)">rldiag</a>	RLDIAG   Raftery-Lewis MCMC convergence diagnostic</li><li><a href="../../minimisers/mcmcstat_new/addbin.html" class="code" title="function status=addbin(filename,x)">addbin</a>	ADDBIN add columns to a V4 matfile</li><li><a href="../../minimisers/mcmcstat_new/covupd.html" class="code" title="function [xcov,xmean,wsum,R]=covupd(x,w,oldcov,oldmean,oldwsum,oldR)">covupd</a>	COVUPD covariance update</li><li><a href="../../minimisers/mcmcstat_new/gammar.html" class="code" title="function y=gammar(m,n,a,b)">gammar</a>	GAMMAR random deviates from gamma distribution</li><li><a href="../../minimisers/mcmcstat_new/geweke.html" class="code" title="function [z,p]=geweke(chain,a,b)">geweke</a>	GEWEKE Geweke's MCMC convergence diagnostic</li><li><a href="../../minimisers/mcmcstat_new/iact.html" class="code" title="function [tau,m] = iact(dati)">iact</a>	IACT estimates the integrated autocorrelation time</li><li><a href="../../minimisers/mcmcstat_new/private/checkoptions.html" class="code" title="function [yesno,bad] = checkoptions(options,goodopts)">checkoptions</a>	CHECKOPIONS check option structure</li><li><a href="../../minimisers/mcmcstat_new/private/getN.html" class="code" title="function n=getN(data)">getN</a>	try to guess number of data lines of data for mcmcrun</li><li><a href="../../minimisers/mcmcstat_new/private/getnbatch.html" class="code" title="function n=getnbatch(data)">getnbatch</a>	try to guess number of batches of mcmc data</li><li><a href="../../minimisers/mcmcstat_new/private/getpar.html" class="code" title="function y=getpar(options,par,default)">getpar</a>	GETPAR get parameter value from a struct</li><li><a href="../../minimisers/mcmcstat_new/reflectivity_fitModel.html" class="code" title="function ss = reflectivity_fitModel(theta,data,problem)">reflectivity_fitModel</a>	Sum of squares function used in the calculation</li><li><a href="../../minimisers/mcmcstat_new/res2par.html" class="code" title="function params = res2par(res,params,loc)">res2par</a>	RES2PAR utility for mcmc tbx</li><li><a href="../../minimisers/mcmcstat_new/rldiag.html" class="code" title="function y=rldiag(chain,q,r,s,e)">rldiag</a>	RLDIAG   Raftery-Lewis MCMC convergence diagnostic</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../minimisers/mcmcstat_new/runBayes.html" class="code" title="function output = runBayes(loop,nsimu,burnin,adaptint,params,problem)">runBayes</a>	Clear any values from previous runs if prsent</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function ss = sseval(ssfun,ssstyle,theta,parind,value,local,data,problem,modelfun)</a></li><li><a href="#_sub2" class="code">function y=alphafun(varargin)</a></li><li><a href="#_sub3" class="code">function z=qfun(iq,varargin)</a></li><li><a href="#_sub4" class="code">function z=lfun(x,y)</a></li><li><a href="#_sub5" class="code">function message(verbosity,level,fmt,varargin)</a></li><li><a href="#_sub6" class="code">function status=wbar(i,nsimu)</a></li><li><a href="#_sub7" class="code">function out = priorfun(th,mu,sig)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [results,chain,s2chain,sschain, hchain]=mcmcrun_compile(model,data,problem,params,options,res)</a>
0002 <span class="comment">%MCMCRUN Metropolis-Hastings MCMC simulation for nonlinear Gaussian models</span>
0003 <span class="comment">% properties:</span>
0004 <span class="comment">%  multiple y-columns, sigma2-sampling, adaptation,</span>
0005 <span class="comment">%  Gaussian prior, parameter limits, delayed rejection, dram</span>
0006 <span class="comment">%</span>
0007 <span class="comment">% [RESULTS,CHAIN,S2CHAIN,SSCHAIN] = MCMCRUN(MODEL,DATA,PARAMS,OPTIONS)</span>
0008 <span class="comment">% MODEL   model options structure</span>
0009 <span class="comment">%    model.ssfun    -2*log(likelihood) function</span>
0010 <span class="comment">%    model.priorfun -2*log(pior) prior function</span>
0011 <span class="comment">%    model.sigma2   initial error variance</span>
0012 <span class="comment">%    model.N        total number of observations</span>
0013 <span class="comment">%    model.S20      prior for sigma2</span>
0014 <span class="comment">%    model.N0       prior accuracy for S20</span>
0015 <span class="comment">%    model.nbatch   number of datasets</span>
0016 <span class="comment">%</span>
0017 <span class="comment">%     sum-of-squares function 'model.ssfun' is called as</span>
0018 <span class="comment">%     ss = ssfun(par,data) or</span>
0019 <span class="comment">%     ss = ssfun(par,data,local)</span>
0020 <span class="comment">%     instead of ssfun, you can use model.modelfun as</span>
0021 <span class="comment">%     ymodel = modelfun(data{ibatch},theta_local)</span>
0022 <span class="comment">%</span>
0023 <span class="comment">%     prior function is called as priorfun(par,pri_mu,pri_sig) it</span>
0024 <span class="comment">%     defaults to Gaussian prior with infinite variance</span>
0025 <span class="comment">%</span>
0026 <span class="comment">%     The parameter sigma2 gives the variances of measured components,</span>
0027 <span class="comment">%     one for each. If the default options.updatesigma = 0 (see below) is</span>
0028 <span class="comment">%     used, sigma2 is fixed, as typically estimated from the fitted residuals.</span>
0029 <span class="comment">%     If opions.updatesigma = 1, the variances are sampled as conjugate priors</span>
0030 <span class="comment">%     specified by the parameters S20 and N0 of the inverse gamma</span>
0031 <span class="comment">%     distribution, with the 'noninformative' defaults</span>
0032 <span class="comment">%          S20 = sigma2   (as given by the user)</span>
0033 <span class="comment">%          N0  = 1</span>
0034 <span class="comment">%     Larger values of N0 limit the samples closer to S20</span>
0035 <span class="comment">%     (see,e.g., A.Gelman et all:</span>
0036 <span class="comment">%     Bayesian Data Analysis, http://www.stat.columbia.edu/~gelman/book/)</span>
0037 <span class="comment">%</span>
0038 <span class="comment">% DATA the data, passed directly to ssfun. The structure of DATA is given</span>
0039 <span class="comment">%      by the user. Typically, it contains the measurements</span>
0040 <span class="comment">%</span>
0041 <span class="comment">%      data.xdata</span>
0042 <span class="comment">%      data.ydata,</span>
0043 <span class="comment">%</span>
0044 <span class="comment">%      A possible 'time' variable must be given in the first column of</span>
0045 <span class="comment">%      xdata. Note that only data.xdata is needed for model simulations.</span>
0046 <span class="comment">%      In addition, DATA may include any user defined structure needed by</span>
0047 <span class="comment">%      |modelfun| or |ssfun|</span>
0048 <span class="comment">%</span>
0049 <span class="comment">% PARAMS  theta structure</span>
0050 <span class="comment">%   {  {'par1',initial, min, max, pri_mu, pri_sig, targetflag, localflag}</span>
0051 <span class="comment">%      {'par2',initial, min, max, pri_mu, pri_sig, targetflag, localflag}</span>
0052 <span class="comment">%      ... }</span>
0053 <span class="comment">%</span>
0054 <span class="comment">%   'name' and initial are compulsary, other values default to</span>
0055 <span class="comment">%   {'name', initial,  -Inf, Inf,  NaN, Inf,  1,  0}</span>
0056 <span class="comment">%</span>
0057 <span class="comment">% OPTIONS mcmc run options</span>
0058 <span class="comment">%    options.nsimu            number of simulations</span>
0059 <span class="comment">%    options.qcov             proposal covariance</span>
0060 <span class="comment">%    options.method           'dram','am','dr', 'ram' or 'mh'</span>
0061 <span class="comment">%    options.adaptint         interval for adaptation, if 'dram' or 'am' used</span>
0062 <span class="comment">%                             DEFAULT adaptint = 100</span>
0063 <span class="comment">%    options.drscale          scaling for proposal stages of dr</span>
0064 <span class="comment">%                             DEFAULT 3 stages, drscale = [5 4 3]</span>
0065 <span class="comment">%    options.updatesigma      update error variance. Sigma2 sampled with updatesigma=1</span>
0066 <span class="comment">%                             DEFAULT updatesigma=0</span>
0067 <span class="comment">%    options.verbosity        level of information printed</span>
0068 <span class="comment">%    options.waitbar          use graphical waitbar?</span>
0069 <span class="comment">%    options.burnintime       burn in before adaptation starts</span>
0070 <span class="comment">%</span>
0071 <span class="comment">% Output:</span>
0072 <span class="comment">%  RESULTS   structure that contains results and information about</span>
0073 <span class="comment">%            the simulations</span>
0074 <span class="comment">%  CHAIN, S2CHAIN, SSCHAIN</span>
0075 <span class="comment">%           parameter, sigma2 and sum-of-squares chains</span>
0076 
0077 <span class="comment">% Marko Laine  2003 &lt;marko.laine@fmi.fi&gt;</span>
0078 <span class="comment">% $Revision: 1.63 $  $Date: 2017/03/30 07:09:39 $</span>
0079 
0080 <span class="comment">%#codegen</span>
0081 <span class="comment">%global invR</span>
0082 
0083 
0084 
0085 <span class="comment">%% check input structs</span>
0086 goodopt={<span class="string">'nsimu'</span>,<span class="string">'adaptint'</span>,<span class="string">'ntry'</span>,<span class="string">'method'</span>,<span class="string">'printint'</span>,<span class="keyword">...</span>
0087         <span class="string">'adaptend'</span>,<span class="string">'lastadapt'</span>,<span class="string">'burnintime'</span>,<span class="string">'waitbar'</span>,<span class="keyword">...</span>
0088         <span class="string">'debug'</span>,<span class="string">'qcov'</span>,<span class="string">'updatesigma'</span>,<span class="string">'noadaptind'</span>,<span class="string">'stats'</span>,<span class="string">'stats2'</span>,<span class="keyword">...</span>
0089         <span class="string">'drscale'</span>,<span class="string">'adascale'</span>,<span class="string">'savesize'</span>,<span class="string">'maxmem'</span>,<span class="string">'chainfile'</span>,<span class="string">'s2chainfile'</span>,<span class="keyword">...</span>
0090         <span class="string">'sschainfile'</span>,<span class="string">'savedir'</span>,<span class="string">'skip'</span>,<span class="string">'label'</span>,<span class="string">'RDR'</span>,<span class="string">'verbosity'</span>,<span class="string">'maxiter'</span>,<span class="keyword">...</span>
0091     <span class="string">'priorupdatestart'</span>,<span class="string">'qcov_adjust'</span>,<span class="string">'burnin_scale'</span>,<span class="string">'alphatarget'</span>,<span class="string">'etaparam'</span>,<span class="keyword">...</span>
0092     <span class="string">'initqcovn'</span>,<span class="string">'savepostinss'</span>};
0093 goodmod={<span class="string">'sigma2'</span>,<span class="string">'N'</span>,<span class="string">'ssfun'</span>,<span class="string">'modelfun'</span>,<span class="string">'priorfun'</span>,<span class="keyword">...</span>
0094      <span class="string">'priortype'</span>,<span class="string">'priorupdatefun'</span>,<span class="string">'priorpars'</span>,<span class="string">'nbatch'</span>,<span class="string">'S20'</span>,<span class="string">'N0'</span>};
0095 [yn,bad]=<a href="../../minimisers/mcmcstat/private/checkoptions.html" class="code" title="function [yesno,bad] = checkoptions(options,goodopts)">checkoptions</a>(options,goodopt);
0096 <span class="keyword">if</span> yn==0
0097   fprintf(<span class="string">'bad options for mcmcrun:\n'</span>);
0098   <span class="keyword">for</span> i=1:length(bad)
0099     fprintf(<span class="string">'\t%s\n'</span>,bad{i});
0100   <span class="keyword">end</span>
0101   fprintf(<span class="string">'available options are:\n'</span>);
0102   <span class="keyword">for</span> i=1:length(goodopt)
0103     fprintf(<span class="string">'\t%s\n'</span>,goodopt{i});
0104   <span class="keyword">end</span>
0105   error(<span class="string">'please check options'</span>);
0106   <span class="keyword">return</span>;
0107 <span class="keyword">end</span>
0108 [yn,bad]=<a href="../../minimisers/mcmcstat/private/checkoptions.html" class="code" title="function [yesno,bad] = checkoptions(options,goodopts)">checkoptions</a>(model,goodmod);
0109 <span class="keyword">if</span> yn==0
0110   fprintf(<span class="string">'bad model options for mcmcrun:\n'</span>);
0111   <span class="keyword">for</span> i=1:length(bad)
0112     fprintf(<span class="string">'\t%s\n'</span>,bad{i});
0113   <span class="keyword">end</span>
0114   fprintf(<span class="string">'available options are:\n'</span>);
0115   <span class="keyword">for</span> i=1:length(goodmod)
0116     fprintf(<span class="string">'\t%s\n'</span>,goodmod{i});
0117   <span class="keyword">end</span>
0118   error(<span class="string">'please check model options'</span>);
0119   <span class="keyword">return</span>;
0120 <span class="keyword">end</span>
0121 
0122 <span class="comment">%% set parameter defaults</span>
0123 <span class="comment">%%% mcmc options</span>
0124 <span class="comment">% some predefined methods</span>
0125 doram = 0;
0126 method = options.method;<span class="comment">%getpar(options,'method','dram');</span>
0127 <span class="keyword">switch</span> lower(method)
0128  <span class="keyword">case</span> <span class="string">'mh'</span>
0129   nsimu    = <a href="../../minimisers/mcmcstat/private/getpar.html" class="code" title="function y=getpar(options,par,default)">getpar</a>(options,<span class="string">'nsimu'</span>,10000);  <span class="comment">% length of the chain to simulate</span>
0130   adaptint = 0;
0131   Ntry     = 1;
0132  <span class="keyword">case</span> <span class="string">'am'</span>
0133   nsimu    = <a href="../../minimisers/mcmcstat/private/getpar.html" class="code" title="function y=getpar(options,par,default)">getpar</a>(options,<span class="string">'nsimu'</span>,10000);
0134   adaptint = <a href="../../minimisers/mcmcstat/private/getpar.html" class="code" title="function y=getpar(options,par,default)">getpar</a>(options,<span class="string">'adaptint'</span>,100); <span class="comment">% update interval for adaptation</span>
0135   Ntry     = 1;
0136  <span class="keyword">case</span> <span class="string">'dr'</span>
0137   nsimu    = <a href="../../minimisers/mcmcstat/private/getpar.html" class="code" title="function y=getpar(options,par,default)">getpar</a>(options,<span class="string">'nsimu'</span>,10000);
0138   adaptint = 0;
0139   Ntry     = <a href="../../minimisers/mcmcstat/private/getpar.html" class="code" title="function y=getpar(options,par,default)">getpar</a>(options,<span class="string">'ntry'</span>,4);       <span class="comment">% DR tries (1 = no extra try)</span>
0140  <span class="keyword">case</span> <span class="string">'dram'</span>
0141   nsimu    = options.nsimu;
0142   adaptint = options.adaptint;
0143   Ntry     = options.ntry;
0144  <span class="keyword">case</span> <span class="string">'ram'</span>
0145   nsimu    = <a href="../../minimisers/mcmcstat/private/getpar.html" class="code" title="function y=getpar(options,par,default)">getpar</a>(options,<span class="string">'nsimu'</span>,10000);
0146   adaptint = 1;
0147   Ntry     = 1;
0148   doram    = 1;
0149   <span class="comment">% options.adascale = 1;</span>
0150  <span class="keyword">otherwise</span>
0151   error(sprintf(<span class="string">'unknown mcmc method: %s'</span>,method));
0152 <span class="keyword">end</span>
0153 printint    = options.printint; <span class="comment">% print interval</span>
0154 lastadapt   = <a href="../../minimisers/mcmcstat/private/getpar.html" class="code" title="function y=getpar(options,par,default)">getpar</a>(options,<span class="string">'lastadapt'</span>,0);  <span class="comment">% last adapt</span>
0155 lastadapt   = <a href="../../minimisers/mcmcstat/private/getpar.html" class="code" title="function y=getpar(options,par,default)">getpar</a>(options,<span class="string">'adaptend'</span>,lastadapt);<span class="comment">%  the same</span>
0156 burnintime  = options.burnintime;
0157 wbarupd     = options.waitbar;<span class="comment">%;    % use graphical waitbar</span>
0158 verbosity   = <a href="../../minimisers/mcmcstat/private/getpar.html" class="code" title="function y=getpar(options,par,default)">getpar</a>(options,<span class="string">'verbosity'</span>,1);  <span class="comment">% amout of info to print</span>
0159 shdebug     = <a href="../../minimisers/mcmcstat/private/getpar.html" class="code" title="function y=getpar(options,par,default)">getpar</a>(options,<span class="string">'debug'</span>,0);      <span class="comment">% show some debug information</span>
0160 qcov        = options.qcov;      <span class="comment">% proposal covariance</span>
0161 initqcovn   = <a href="../../minimisers/mcmcstat/private/getpar.html" class="code" title="function y=getpar(options,par,default)">getpar</a>(options,<span class="string">'initqcovn'</span>,[]);      <span class="comment">% proposal covariance weight in update</span>
0162 qcov_adjust = <a href="../../minimisers/mcmcstat/private/getpar.html" class="code" title="function y=getpar(options,par,default)">getpar</a>(options,<span class="string">'qcov_adjust'</span>,1e-8); <span class="comment">% eps adjustment</span>
0163 burnin_scale= <a href="../../minimisers/mcmcstat/private/getpar.html" class="code" title="function y=getpar(options,par,default)">getpar</a>(options,<span class="string">'burnin_scale'</span>,10); <span class="comment">% scale in burn-in down/up</span>
0164 updatesigma = options.updatesigma;
0165 noadaptind  = <a href="../../minimisers/mcmcstat/private/getpar.html" class="code" title="function y=getpar(options,par,default)">getpar</a>(options,<span class="string">'noadaptind'</span>,[]); <span class="comment">% do not adapt these indeses</span>
0166 dostats     = options.stats;       <span class="comment">% convergence statistics</span>
0167 dostats2    = <a href="../../minimisers/mcmcstat/private/getpar.html" class="code" title="function y=getpar(options,par,default)">getpar</a>(options,<span class="string">'stats2'</span>,0);       <span class="comment">% convergence statistics</span>
0168 <span class="comment">% DR options</span>
0169 dodram   = 1;<span class="comment">%getpar(options,'dram',0); % DR (not used, use ntry instead)</span>
0170 <span class="comment">%DR_scale = getpar(options,'drscale',[60 30 15]);</span>
0171 DR_scale = <a href="../../minimisers/mcmcstat/private/getpar.html" class="code" title="function y=getpar(options,par,default)">getpar</a>(options,<span class="string">'drscale'</span>,[5 4 3]);
0172 adascale = <a href="../../minimisers/mcmcstat/private/getpar.html" class="code" title="function y=getpar(options,par,default)">getpar</a>(options,<span class="string">'adascale'</span>,[]); <span class="comment">% qcov_scale</span>
0173 <span class="keyword">if</span> Ntry &gt; 1, dodram=1; <span class="keyword">end</span>
0174 <span class="comment">% RAM options</span>
0175 alphatarget = <a href="../../minimisers/mcmcstat/private/getpar.html" class="code" title="function y=getpar(options,par,default)">getpar</a>(options,<span class="string">'alphatarget'</span>,0.234); <span class="comment">% acceptance ratio target</span>
0176 etaparam = <a href="../../minimisers/mcmcstat/private/getpar.html" class="code" title="function y=getpar(options,par,default)">getpar</a>(options,<span class="string">'etaparam'</span>,0.7); <span class="comment">%</span>
0177 
0178 <span class="comment">% save options</span>
0179 <span class="comment">% savesize   = getpar(options,'savesize',0); % rows of the chain in memory</span>
0180 <span class="comment">% if savesize &lt;= 0 || savesize &gt; nsimu</span>
0181    savesize = nsimu;
0182 <span class="comment">% end</span>
0183 <span class="comment">% maxmem      = getpar(options,'maxmem',0); % memory available in mega bytes</span>
0184 <span class="comment">% temporary files if dumping to file</span>
0185 <span class="comment">% savedir     = '';% getpar(options,'savedir',tempdir);</span>
0186 <span class="comment">% fnum = fix(rand*100000); % random number for the default filename</span>
0187 <span class="comment">% chainfile   = getpar(options,'chainfile',sprintf('chain_%05d.mat',fnum));</span>
0188 <span class="comment">% s2chainfile = getpar(options,'s2chainfile',sprintf('s2chain_%05d.mat',fnum));</span>
0189 <span class="comment">% sschainfile = getpar(options,'sschainfile',sprintf('sschain_%05d.mat',fnum));</span>
0190 <span class="comment">% skip        = getpar(options,'skip',1);</span>
0191 <span class="comment">% if ~isempty(savedir)</span>
0192 <span class="comment">%   chainfile   = [savedir,chainfile];</span>
0193 <span class="comment">%   s2chainfile = [savedir,s2chainfile];</span>
0194 <span class="comment">%   sschainfile = [savedir,sschainfile];</span>
0195 <span class="comment">% end</span>
0196 <span class="comment">% label = getpar(options,'label',sprintf('MCMC run at %s',date));</span>
0197 
0198 <span class="comment">% save -2*log(ss/sigma2+prior) in sschain instead of ss</span>
0199 savepostinss = <a href="../../minimisers/mcmcstat/private/getpar.html" class="code" title="function y=getpar(options,par,default)">getpar</a>(options,<span class="string">'savepostinss'</span>,0);
0200 
0201 <span class="comment">% Model options</span>
0202 sigma2  = <a href="../../minimisers/mcmcstat/private/getpar.html" class="code" title="function y=getpar(options,par,default)">getpar</a>(model,<span class="string">'sigma2'</span>,[]);     <span class="comment">% initial value for the error variance</span>
0203 N       = <a href="../../minimisers/mcmcstat/private/getpar.html" class="code" title="function y=getpar(options,par,default)">getpar</a>(model,<span class="string">'N'</span>,<a href="../../minimisers/mcmcstat/private/getN.html" class="code" title="function n=getN(data)">getN</a>(data));  <span class="comment">% no of obs</span>
0204 ssfun   = <a href="../../minimisers/mcmcstat/private/getpar.html" class="code" title="function y=getpar(options,par,default)">getpar</a>(model,<span class="string">'ssfun'</span>,[]);      <span class="comment">% sum of squares function</span>
0205 modelfun= <a href="../../minimisers/mcmcstat/private/getpar.html" class="code" title="function y=getpar(options,par,default)">getpar</a>(model,<span class="string">'modelfun'</span>,[]);   <span class="comment">% model function</span>
0206 <span class="comment">%priorfun= getpar(model,'priorfun',[]);   % prior function</span>
0207 priortype= <a href="../../minimisers/mcmcstat/private/getpar.html" class="code" title="function y=getpar(options,par,default)">getpar</a>(model,<span class="string">'priortype'</span>,1);  <span class="comment">% prior type, 1 = Gaussian</span>
0208 priorupdatefun = <a href="../../minimisers/mcmcstat/private/getpar.html" class="code" title="function y=getpar(options,par,default)">getpar</a>(model,<span class="string">'priorupdatefun'</span>,[]); <span class="comment">% prior parameter update</span>
0209 priorpars = <a href="../../minimisers/mcmcstat/private/getpar.html" class="code" title="function y=getpar(options,par,default)">getpar</a>(model,<span class="string">'priorpars'</span>,[]); <span class="comment">% prior parameter for priorupdatefun</span>
0210 priorupdatestart = <a href="../../minimisers/mcmcstat/private/getpar.html" class="code" title="function y=getpar(options,par,default)">getpar</a>(options,<span class="string">'priorupdatestart'</span>,burnintime);
0211 <span class="comment">%ssstyle = getpar(model,'ssstyle',1);</span>
0212 ssstyle = 1;
0213 <span class="comment">% error variance prior</span>
0214 S20     = <a href="../../minimisers/mcmcstat/private/getpar.html" class="code" title="function y=getpar(options,par,default)">getpar</a>(model,<span class="string">'S20'</span>,1);
0215 N0      = <a href="../../minimisers/mcmcstat/private/getpar.html" class="code" title="function y=getpar(options,par,default)">getpar</a>(model,<span class="string">'N0'</span>,[]);
0216 nbatch  = <a href="../../minimisers/mcmcstat/private/getpar.html" class="code" title="function y=getpar(options,par,default)">getpar</a>(model,<span class="string">'nbatch'</span>,<a href="../../minimisers/mcmcstat/private/getnbatch.html" class="code" title="function n=getnbatch(data)">getnbatch</a>(data)); <span class="comment">% number of batches</span>
0217 
0218 <span class="comment">% This is for backward compatibility</span>
0219 <span class="comment">% if sigma2 given then default N0=1, else default N0=0</span>
0220 <span class="comment">% if isempty(N0)</span>
0221 <span class="comment">%   if isempty(sigma2)</span>
0222     sigma2 = 1;
0223     N0 = 0;
0224 <span class="comment">%   else</span>
0225 <span class="comment">%     N0 = 1;</span>
0226 <span class="comment">%   end</span>
0227 <span class="comment">% else</span>
0228   <span class="comment">% if N0 given, then also check updatesigma</span>
0229   updatesigma = 0;
0230 <span class="comment">%end</span>
0231 
0232 <span class="keyword">if</span> isempty(N)
0233   <span class="keyword">if</span> updatesigma
0234     error(<span class="string">'could not determine number of data points, please specify model.N'</span>);
0235   <span class="keyword">end</span>
0236 <span class="keyword">end</span>
0237 <span class="keyword">if</span> isempty(nbatch)
0238   <a href="#_sub5" class="code" title="subfunction message(verbosity,level,fmt,varargin)">message</a>(verbosity,1,<span class="string">'Setting nbatch to 1\n'</span>);
0239   nbatch = 1;
0240 <span class="keyword">end</span>
0241 
0242 
0243 <span class="comment">% some values from the previous run</span>
0244 <span class="keyword">if</span> nargin &gt; 4 &amp;&amp; ~isempty(res)
0245   <a href="#_sub5" class="code" title="subfunction message(verbosity,level,fmt,varargin)">message</a>(verbosity,0,<span class="string">'Using values from the previous run\n'</span>)
0246   params = <a href="res2par.html" class="code" title="function params = res2par(res,params,loc)">res2par</a>(res,params, 1 ); <span class="comment">% 1 = do local parameters</span>
0247   qcov   = res.qcov2;
0248   <span class="keyword">if</span> isempty(initqcovn)
0249     initqcovn = res.nsimu;
0250   <span class="keyword">end</span>
0251 <span class="keyword">end</span>
0252 
0253 <span class="comment">% open and parse the parameter structure</span>
0254 <span class="comment">% [names,value,parind,local,upp,low,thetamu,thetasig,hyperpars] = ...</span>
0255 <span class="comment">%     openparstruct(params,nbatch);</span>
0256 
0257 <span class="comment">% Use a stripped down version of 'openparstruct' for RAT</span>
0258 <span class="comment">% comiple.</span>
0259 [names,value,parind,local,upp,low,thetamu,thetasig,hyperpars] = <span class="keyword">...</span>
0260     openparstruct_compile(params,nbatch);
0261 
0262 
0263 <span class="keyword">if</span> any(thetasig&lt;=0)
0264   disp(<span class="string">'some prior variances &lt;=0, setting those to Inf'</span>)
0265   thetasig(thetasig&lt;=0) = Inf;
0266 <span class="keyword">end</span>
0267 
0268 <span class="comment">% hyper prior parameters</span>
0269 <span class="comment">% hchain = []; % it is allocated after the first call inside the simuloop</span>
0270 <span class="comment">% nhpar = int32(hyperpars.nhpar);</span>
0271 <span class="comment">% if hyperpars.nhpar &gt; 0</span>
0272 <span class="comment">%   fprintf('NOTE: n:o of parameters with hyper priors is %d\n',nhpar);</span>
0273 <span class="comment">%   if isempty(priorpars), priorpars=hyperpars;end</span>
0274 <span class="comment">%   if isempty(priorupdatefun), priorupdatefun=@hyperpriorupdate;disp('  using the default hyper update method');end</span>
0275 <span class="comment">% end</span>
0276 
0277 <span class="comment">% default for sigma2 is S20 or 1</span>
0278 <span class="comment">% if isempty(sigma2)</span>
0279 <span class="comment">%   if not(isnan(S20))</span>
0280 <span class="comment">%     sigma2=S20;</span>
0281 <span class="comment">%   else</span>
0282 <span class="comment">%     sigma2=1;</span>
0283 <span class="comment">%   end</span>
0284 <span class="comment">% end</span>
0285 <span class="comment">% if isnan(S20)</span>
0286 <span class="comment">%   S20 = sigma2; % prior parameters for the error variance</span>
0287 <span class="comment">% end</span>
0288 <span class="comment">% if isnan(N0)</span>
0289 <span class="comment">%   N0 = 1;</span>
0290 <span class="comment">% end</span>
0291 
0292 S20 = 1;
0293 
0294 <span class="keyword">if</span> lastadapt&lt;1
0295   lastadapt=nsimu;
0296 <span class="keyword">end</span>
0297 <span class="keyword">if</span> isnan(printint)
0298   printint = max(100,min(1000,adaptint));
0299 <span class="keyword">end</span>
0300 
0301 <span class="comment">% if verbosity&gt;0</span>
0302 <span class="comment">%   fprintf('Sampling these parameters:\nname   start [min,max] N(mu,s^2)\n');</span>
0303 <span class="comment">%   nprint = length(parind);</span>
0304 <span class="comment">%   if verbosity == 1</span>
0305 <span class="comment">%     nprint = min(nprint,40);</span>
0306 <span class="comment">%   end</span>
0307 <span class="comment">%   for i=1:nprint</span>
0308 <span class="comment">%     if ismember(i,noadaptind), st=' (*)'; else st='';end</span>
0309 <span class="comment">%     if isinf(thetasig(parind(i))), h2=''; else h2='^2';end</span>
0310 <span class="comment">%     fprintf('%s: %g [%g,%g] N(%g,%g%s)%s\n',...</span>
0311 <span class="comment">%             names{parind(i)},value(parind(i)),...</span>
0312 <span class="comment">%             low(parind(i)),upp(parind(i)),...</span>
0313 <span class="comment">%             thetamu(parind(i)),thetasig(parind(i)),h2,st);</span>
0314 <span class="comment">%   end</span>
0315 <span class="comment">%   if nprint &lt; length(parind), fprintf('...\n'); end</span>
0316 <span class="comment">% end</span>
0317 
0318 par0 = value(parind);
0319 npar = length(par0);
0320 
0321 <span class="comment">% check ssfun type</span>
0322 <span class="comment">% Don't need to do this as always the same</span>
0323 <span class="comment">% type</span>
0324 ssstyle = 1;
0325 <span class="comment">% if isempty(ssfun)</span>
0326 <span class="comment">%   if isempty(modelfun)</span>
0327 <span class="comment">%     error('no ssfun or modelfun!')</span>
0328 <span class="comment">%   end</span>
0329 <span class="comment">%   ssstyle = 4;</span>
0330 <span class="comment">%   ni = 4;</span>
0331 <span class="comment">% else</span>
0332 <span class="comment">%   if isa(ssfun,'function_handle')</span>
0333 <span class="comment">% %    ni = nargin(func2str(ssfun)); % is this needed?</span>
0334 <span class="comment">%     ni = nargin(ssfun);</span>
0335 <span class="comment">%   elseif isa(ssfun,'inline') || exist(ssfun) == 2 % ssfun is an mfile</span>
0336 <span class="comment">%     ni = nargin(ssfun);</span>
0337 <span class="comment">%   else</span>
0338 <span class="comment">%     ni = 2;</span>
0339 <span class="comment">%   end</span>
0340 <span class="comment">%   if ni == 3</span>
0341 <span class="comment">%     ssstyle=2;</span>
0342 <span class="comment">%   end</span>
0343 <span class="comment">% end</span>
0344 
0345 <span class="comment">% We allways input qcov</span>
0346 <span class="comment">% if isempty(qcov)</span>
0347 <span class="comment">%   qcov = thetasig.^2;</span>
0348 <span class="comment">%   ii = isinf(qcov)|isnan(qcov);</span>
0349 <span class="comment">% %  qcov(ii) = [abs(par0(ii))*0.05].^2; % default is 5% std</span>
0350 <span class="comment">%   qcov(ii) = [abs(value(ii))*0.05].^2; % default is 5% std</span>
0351 <span class="comment">%   qcov(qcov==0) = 1e-6; % .. or one if we start from zero</span>
0352 <span class="comment">%   % If any are zero, use value of high limit instead</span>
0353 <span class="comment">% %   for n = 1:length(qcov);</span>
0354 <span class="comment">% %       if iszero(qcov(n))</span>
0355 <span class="comment">% %           thisPar = params{n};</span>
0356 <span class="comment">% %           thisPar = thisPar{4};</span>
0357 <span class="comment">%</span>
0358 <span class="comment">%</span>
0359 <span class="comment">%   qcov = diag(qcov);</span>
0360 <span class="comment">% end</span>
0361 
0362 <span class="keyword">if</span> isempty(adascale)||adascale&lt;=0
0363   qcov_scale = 2.4 / sqrt(npar) ; <span class="comment">% scale factor in R</span>
0364 <span class="keyword">else</span>
0365   qcov_scale = adascale;
0366 <span class="keyword">end</span>
0367 
0368 <span class="comment">% [cm,cn]=size(qcov);</span>
0369 <span class="comment">% if min([cm cn]) == 1 % qcov contains variances!</span>
0370 <span class="comment">%   s = sqrt(qcov(parind));</span>
0371 <span class="comment">%   R = diag(s); % *qcov_scale; % do NOT scale the initial qcov</span>
0372 <span class="comment">%   qcovorig = diag(qcov); % save qcov</span>
0373 <span class="comment">%   qcov = diag(qcov(parind));</span>
0374 <span class="comment">% else %  qcov has covariance matrix in it</span>
0375   qcovorig = qcov; <span class="comment">% save qcov</span>
0376   qcov = qcov(parind,parind);
0377   R    = chol(qcov); <span class="comment">% *qcov_scale;</span>
0378 <span class="comment">%end</span>
0379 <span class="comment">%R0 = R; % save R</span>
0380 
0381 <span class="keyword">global</span> A_count
0382 A_count = 0; <span class="comment">% alphafun count</span>
0383 RDR = cell(1,Ntry);
0384 RDR{1} = [];
0385 
0386 define_invR = cell(1,Ntry);
0387 <span class="keyword">for</span> i = 1:Ntry
0388     define_invR{i} = i;
0389 <span class="keyword">end</span>
0390 
0391 invR = define_invR;
0392 
0393 <span class="comment">%invR{1} = [];</span>
0394 <span class="keyword">if</span> dodram
0395 <span class="comment">%   RDR = getpar(options,'RDR',{}); % RDR qiven in ooptions</span>
0396 <span class="comment">%   if ~isempty(RDR)</span>
0397 <span class="comment">%     for i=1:Ntry</span>
0398 <span class="comment">%       invR{i} = RDR{i}\eye(npar);</span>
0399 <span class="comment">%     end</span>
0400 <span class="comment">%     R = RDR{1};</span>
0401 <span class="comment">%   else</span>
0402     <span class="comment">% DR strategy: just scale R's down by DR_scale</span>
0403     RDR{1} = R;
0404     invR{1} = R\eye(npar);
0405     <span class="keyword">for</span> i=2:Ntry
0406       RDR{i}  = RDR{i-1}./DR_scale(min(i-1,length(DR_scale)));
0407       invR{i} = RDR{i}\eye(npar);
0408     <span class="keyword">end</span>
0409   <span class="comment">%end</span>
0410   iacce = zeros(1,Ntry);
0411 <span class="keyword">end</span>
0412 
0413 <span class="comment">%starttime=clock;</span>
0414 
0415 oldpar=par0(:)';
0416 ss = <a href="#_sub1" class="code" title="subfunction ss = sseval(ssfun,ssstyle,theta,parind,value,local,data,problem,modelfun)">sseval</a>(ssfun,ssstyle,oldpar,parind,value,local,data,problem,modelfun);
0417 ss1 = ss;
0418 ss2 = ss;
0419 
0420 ny = length(ss);
0421 <span class="keyword">if</span> length(S20)==1
0422   S20 = ones(1,ny)*S20;
0423 <span class="keyword">end</span>
0424 <span class="keyword">if</span> length(N)==1
0425   N = ones(1,ny)*N;
0426 <span class="keyword">end</span>
0427 <span class="keyword">if</span> length(N)==ny+1
0428   N = N(2:end); <span class="comment">% remove first columns FIXME</span>
0429 <span class="keyword">end</span>
0430 <span class="keyword">if</span> length(N0)==1
0431   N0 = ones(1,ny)*N0;
0432 <span class="keyword">end</span>
0433 
0434 <span class="comment">% default prior function calculates Gaussian sum of squares</span>
0435 <span class="comment">%if isempty(priorfun)</span>
0436 <span class="comment">%  priorfun = @(th,mu,sig) sum(((th-mu)./sig).^2);</span>
0437 <span class="comment">%end</span>
0438 
0439 oldprior = <a href="#_sub7" class="code" title="subfunction out = priorfun(th,mu,sig)">priorfun</a>(oldpar,thetamu(parind),thetasig(parind));
0440 
0441 <span class="comment">%memory calculations</span>
0442 <span class="comment">% memneeded = savesize*(npar+2*ny)*8*1e-6;</span>
0443 <span class="comment">% if (maxmem &gt; 0) &amp;&amp; (memneeded &gt; maxmem)</span>
0444 <span class="comment">%   savesize = max(1000,floor(maxmem/(npar+2*ny)/8*1e6));</span>
0445 <span class="comment">%   message(verbosity,0,'savesize decreased to %d\n',savesize);</span>
0446 <span class="comment">% end</span>
0447 <span class="comment">% if (savesize &lt; nsimu) || (nargout &lt; 2)</span>
0448 <span class="comment">%   saveit = 1;</span>
0449 <span class="comment">% else</span>
0450 <span class="comment">%   saveit = 0;</span>
0451 <span class="comment">% end</span>
0452 <span class="comment">% save parameters, error variance, and SS</span>
0453 chain   = zeros(savesize,npar);
0454 <span class="keyword">if</span> updatesigma
0455   s2chain = zeros(savesize,ny);
0456 <span class="keyword">else</span>
0457   s2chain = [];
0458 <span class="keyword">end</span>
0459 sschain = zeros(savesize,ny);
0460 
0461 <span class="comment">% %% save chain</span>
0462 <span class="comment">% if saveit == 1</span>
0463 <span class="comment">%   savebin(chainfile,[],'chain');</span>
0464 <span class="comment">%   savebin(sschainfile,[],'sschain');</span>
0465 <span class="comment">%   if updatesigma</span>
0466 <span class="comment">%     savebin(s2chainfile,[],'s2chain');</span>
0467 <span class="comment">%   end</span>
0468 <span class="comment">% end</span>
0469 
0470 chain(1,:)   = oldpar;
0471 <span class="keyword">if</span> updatesigma
0472   s2chain(1,:) = sigma2;
0473 <span class="keyword">end</span>
0474 <span class="keyword">if</span> savepostinss
0475   sschain(1,:) = ss./sigma2 + oldprior;
0476 <span class="keyword">else</span>
0477   sschain(1,:) = ss;
0478 <span class="keyword">end</span>
0479 
0480 rej=0; reju=0; ii=1; rejl = 0;
0481 <span class="comment">%% setup waitbar</span>
0482 <span class="keyword">if</span> wbarupd; textProgressBar(<span class="string">'init'</span>,0); <span class="keyword">end</span>
0483 
0484 <span class="comment">% covariance update uses these to store previous values</span>
0485 covchain = []; meanchain = []; wsum = initqcovn; lasti = 0;
0486 <span class="keyword">if</span> not(isempty(wsum))
0487   covchain = qcov;
0488   meanchain = oldpar;
0489 <span class="keyword">end</span>
0490 <span class="comment">% no update for these indeses</span>
0491 noupd = logical(zeros(1,npar));
0492 noupd(intersect(parind,noadaptind)) = 1;
0493 
0494 <span class="comment">% extra statistics for method testing</span>
0495 <span class="keyword">if</span> dostats2
0496   accechain = zeros(nsimu,1); <span class="comment">% for cumulative acceptance</span>
0497   accechain(1) = 1;
0498   <span class="keyword">if</span> dodram
0499     evalchain = ones(nsimu,1); <span class="comment">% for likelihood evaluations</span>
0500   <span class="keyword">end</span>
0501 <span class="keyword">end</span>
0502 
0503 chainind = 1; <span class="comment">% where we are in chain</span>
0504 <span class="keyword">for</span> isimu=2:nsimu <span class="comment">% simulation loop</span>
0505   ii = ii+1; <span class="comment">% local adaptation index (?)</span>
0506   chainind = chainind+1;
0507 
0508   <span class="comment">% waitbar</span>
0509   <span class="keyword">if</span> wbarupd
0510     <span class="comment">%status = wbar(isimu,nsimu);</span>
0511 <span class="comment">%     if status == -1 % waitbar killed, cancel the run and keep</span>
0512 <span class="comment">%                     % the chain so far</span>
0513 <span class="comment">%       message(verbosity,1,'Cancelling...\n');</span>
0514 <span class="comment">%       chainind = chainind-1;</span>
0515 <span class="comment">%       nsimu = isimu;</span>
0516 <span class="comment">%       chain = chain(1:chainind,:);</span>
0517 <span class="comment">%       sschain = sschain(1:chainind,:);</span>
0518 <span class="comment">%       if updatesigma</span>
0519 <span class="comment">%         s2chain = s2chain(1:chainind,:);</span>
0520 <span class="comment">%       end</span>
0521 <span class="comment">%       if size(hchain,1)&gt;1</span>
0522 <span class="comment">%         hchain = hchain(1:chainind,:);</span>
0523 <span class="comment">%       end</span>
0524 <span class="comment">%       break % break the nsimu loop</span>
0525 <span class="comment">%     end</span>
0526   <span class="keyword">end</span>
0527   <a href="#_sub5" class="code" title="subfunction message(verbosity,level,fmt,varargin)">message</a>(verbosity,100,<span class="string">'i:%d/%d\n'</span>,isimu,nsimu);
0528 
0529   <span class="comment">% sample new candidate from Gaussian proposal</span>
0530   u = randn(1,npar);
0531   newpar=oldpar+u*R;
0532 
0533   <span class="comment">% reject points outside boundaries</span>
0534   <span class="keyword">if</span> any(newpar&lt;low(parind)) || any(newpar&gt;upp(parind))
0535     accept = 0;
0536     newprior = 0;
0537     tst      = 0;
0538     ss1      = Inf;
0539     ss2      = ss;
0540     outbound = 1;
0541   <span class="keyword">else</span>
0542     outbound = 0;
0543     <span class="comment">% prior SS for the new theta</span>
0544     newprior = <a href="#_sub7" class="code" title="subfunction out = priorfun(th,mu,sig)">priorfun</a>(newpar,thetamu(parind),thetasig(parind));
0545 
0546     <span class="comment">% calculate ss</span>
0547     ss2 = ss;             <span class="comment">% old ss</span>
0548     ss1 = <a href="#_sub1" class="code" title="subfunction ss = sseval(ssfun,ssstyle,theta,parind,value,local,data,problem,modelfun)">sseval</a>(ssfun,ssstyle,newpar,parind,value,local,data,problem,modelfun);
0549 
0550     tst = exp(-0.5*( sum((ss1-ss2)./sigma2) + newprior-oldprior) );
0551 
0552     <span class="keyword">if</span> tst &lt;= 0
0553       accept = 0;
0554     <span class="keyword">elseif</span> tst &gt;= 1
0555       accept = 1;
0556     <span class="keyword">elseif</span> tst &gt; rand(1,1)
0557       accept = 1;
0558     <span class="keyword">else</span>
0559       accept = 0;
0560     <span class="keyword">end</span>
0561     <span class="keyword">if</span> shdebug &amp;&amp; fix(isimu/shdebug) == isimu/shdebug
0562       fprintf(<span class="string">'%d: pri: %g, tst: %g, ss: %g\n'</span>,isimu, newprior,tst, ss1);
0563     <span class="keyword">end</span>
0564   <span class="keyword">end</span>
0565   
0566   
0567   str = struct(<span class="string">'p'</span>,{0},<span class="string">'ss'</span>,{0},<span class="string">'pri'</span>,{0},<span class="string">'s2'</span>,{0},<span class="string">'a'</span>,{0});
0568   x = str;
0569   y = str;
0570   z = str;
0571   
0572   <span class="comment">%%% DR -----------------------------------------------------</span>
0573   <span class="keyword">if</span> dodram == 1 &amp;&amp; accept == 0 <span class="comment">% &amp; outbound == 0</span>
0574     <span class="comment">% we do a new try according to delayed rejection</span>
0575     x.p   = oldpar;
0576     x.ss  = ss2;
0577     x.pri = oldprior;
0578     x.s2  = sigma2;
0579 
0580     y.p   = newpar;
0581     y.ss  = ss1;
0582     y.pri = newprior;
0583     y.s2  = sigma2;
0584     y.a   = tst;
0585     
0586     z.p = zeros(1,npar);
0587     coder.varsize(<span class="string">'zs2'</span>);
0588     zs2 = 0;
0589     z.s2 = zs2;
0590     z.a = 0;
0591     z.pri = 0;
0592     z.ss = 0;
0593     
0594     trypath = {x,y,z};
0595     itry    = 1;
0596     <span class="keyword">while</span> accept == 0 &amp;&amp; itry &lt; Ntry
0597       itry = itry+1;
0598       z.p  = x.p + randn(1,npar)*RDR{itry};
0599       z.s2 = sigma2;
0600       <span class="keyword">if</span> any(z.p&lt;low(parind)) || any(z.p&gt;upp(parind))
0601         z.a   = 0;
0602         z.pri = 0;
0603         z.ss  = Inf;
0604         trypath = {trypath{1:2},z};
0605         outbound = 1;
0606         <span class="keyword">continue</span>
0607       <span class="keyword">end</span>
0608 
0609       outbound = 0;
0610       z.ss = <a href="#_sub1" class="code" title="subfunction ss = sseval(ssfun,ssstyle,theta,parind,value,local,data,problem,modelfun)">sseval</a>(ssfun,ssstyle,z.p,parind,value,local,data,problem,modelfun);
0611       z.pri = <a href="#_sub7" class="code" title="subfunction out = priorfun(th,mu,sig)">priorfun</a>(z.p,thetamu(parind),thetasig(parind));
0612       trypath = {trypath{1:2},z};
0613       alpha = <a href="#_sub2" class="code" title="subfunction y=alphafun(varargin)">alphafun</a>(trypath{:});
0614       trypath{end}.a = alpha;
0615       <span class="keyword">if</span> alpha &gt;= 1 || rand(1,1) &lt; alpha     <span class="comment">%  accept</span>
0616         accept   = 1;
0617         newpar   = z.p;
0618         ss1      = z.ss;
0619         newprior = z.pri;
0620         iacce(itry) = iacce(itry) + 1;
0621       <span class="keyword">end</span>
0622       <span class="keyword">if</span> shdebug &amp;&amp; fix(isimu/shdebug) == isimu/shdebug
0623         fprintf(<span class="string">'try %d: pri: %g, alpha: %g\n'</span>,itry, z.pri, alpha);
0624         fprintf(<span class="string">' p: %g\n'</span>,z.p);
0625       <span class="keyword">end</span>
0626     <span class="keyword">end</span>
0627     <span class="keyword">if</span> dostats2
0628       evalchain(chainind) = itry;
0629     <span class="keyword">end</span>
0630   <span class="keyword">end</span> <span class="comment">% DR --------------------------------------------------------</span>
0631   <span class="comment">%%% save chain</span>
0632   <span class="keyword">if</span> accept
0633     <span class="comment">%%% accept</span>
0634     chain(chainind,:) = newpar;
0635     oldpar     = newpar;
0636     oldprior   = newprior;
0637     ss         = ss1;
0638     <span class="keyword">if</span> dostats2
0639       accechain(chainind) = 1;
0640     <span class="keyword">end</span>
0641   <span class="keyword">else</span>
0642     <span class="comment">%%%% reject</span>
0643     chain(chainind,:) = oldpar;
0644     rej        = rej + 1;
0645     reju       = reju + 1;
0646     <span class="keyword">if</span> outbound
0647       rejl     = rejl + 1;
0648     <span class="keyword">end</span>
0649   <span class="keyword">end</span>
0650   <span class="comment">%%% Possibly update the prior parameters (for testing hiearchical hyper priors)</span>
0651   <span class="comment">%%% [mu,sig]=priorupdatefun(theta, mu, sig, priorpars)</span>
0652   <span class="keyword">if</span> not(isempty(priorupdatefun)) &amp;&amp; hyperpars.nhpar &gt; 0
0653     <span class="keyword">if</span> isimu==2 || isimu&gt;=priorupdatestart
0654       [muout,sigout,hrowout] = <span class="keyword">...</span>
0655       feval(priorupdatefun,oldpar,thetamu(parind),thetasig(parind),priorpars);
0656       <span class="keyword">if</span> isimu==2 <span class="comment">% set up hchain</span>
0657         hchain = zeros(nsimu,length(hrowout));
0658     <span class="keyword">if</span> isfield(priorpars,<span class="string">'mu0'</span>) &amp;&amp; isfield(priorpars,<span class="string">'sig20'</span>) &amp;&amp; <span class="keyword">...</span>
0659           length([priorpars.mu0,priorpars.sig20]) == length(hrowout)
0660       hchain(1,1:2:end) = priorpars.mu0;
0661       hchain(1,2:2:end) = sqrt(priorpars.sig20);
0662       hrow = hchain(1,:);
0663     <span class="keyword">end</span>
0664       <span class="keyword">end</span>
0665       <span class="keyword">if</span> isimu&gt;=priorupdatestart; <span class="comment">% update mu and theta</span>
0666     thetamu(parind)  = muout;
0667     thetasig(parind) = sigout;
0668     hrow = hrowout;
0669     <span class="comment">% need to update the prior ss value</span>
0670     oldprior = feval(<a href="#_sub7" class="code" title="subfunction out = priorfun(th,mu,sig)">priorfun</a>,oldpar,thetamu(parind),thetasig(parind));
0671       <span class="keyword">end</span>
0672     <span class="keyword">end</span>
0673     hchain(isimu,:) = hrow;
0674     <span class="comment">%% fix this:</span>
0675     <span class="comment">%% (do?) we need &quot;sum of squares&quot; of the hyper parameters for the observation</span>
0676     <span class="comment">%% noise sigma2 update</span>
0677 <span class="comment">%    sig2s = hrow(2:2:end).^2; % now assumes that we are using the default function</span>
0678 <span class="comment">%    sssig = sum(sig2s);</span>
0679 <span class="comment">%    sign = length(sig2s)*nbatch;</span>
0680   <span class="keyword">else</span>
0681 <span class="comment">%    sssig = 0;</span>
0682 <span class="comment">%    sign = 0;</span>
0683   <span class="keyword">end</span>
0684   <span class="comment">%%%</span>
0685   <span class="comment">%%% update sigma2</span>
0686   <span class="keyword">if</span> updatesigma
0687     <span class="keyword">for</span> j=1:ny
0688      sigma2(j) = 1./<a href="gammar.html" class="code" title="function y=gammar(m,n,a,b)">gammar</a>(1,1,(N0(j)+N(j))/2,2./(N0(j).*S20(j)+ss(j)));
0689  <span class="comment">%     nn = N0(j)+N(j)+sign;</span>
0690  <span class="comment">%     sigma2(j) = invchir(1,1, nn , (N0(j).*S20(j)+ss(j) + sssig)./nn);</span>
0691  <span class="comment">%     sigma2(j) =  1./gammar(1,1,(N0(j)+N(j)+sign)/2,2./(N0(j).*S20(j)+ss(j)+sssig ));</span>
0692     <span class="keyword">end</span>
0693     s2chain(chainind,:) = sigma2;
0694   <span class="keyword">end</span>
0695   <span class="comment">%%%</span>
0696   <span class="keyword">if</span> savepostinss
0697     sschain(chainind,:) = ss./sigma2 + oldprior;
0698   <span class="keyword">else</span>
0699     sschain(chainind,:) = ss;
0700   <span class="keyword">end</span>
0701   <span class="comment">%</span>
0702   <span class="keyword">if</span> printint &amp;&amp; fix(isimu/printint) == isimu/printint
0703 <span class="comment">%     message(verbosity,2,'i:%g (%3.2f,%3.2f,%3.2f)\n', ...</span>
0704 <span class="comment">%             isimu,rej/isimu*100,reju/ii*100,rejl/isimu*100);</span>
0705     <a href="#_sub6" class="code" title="subfunction status=wbar(i,nsimu)">wbar</a>(isimu,nsimu);
0706   <span class="keyword">end</span>
0707 
0708   <span class="comment">%% adaptation %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0709   <span class="keyword">if</span> adaptint&gt;0 &amp;&amp; isimu&lt;=lastadapt &amp;&amp; fix(isimu/adaptint) == isimu/adaptint
0710     <span class="keyword">if</span> isimu &lt; burnintime
0711       <span class="comment">% During burnin no adaptation, just scaling up/down</span>
0712       <span class="keyword">if</span> reju/ii &gt; 0.95
0713         <a href="#_sub5" class="code" title="subfunction message(verbosity,level,fmt,varargin)">message</a>(verbosity,2,<span class="string">' (burnin/down) %3.2f'</span>,reju/ii*100);
0714         R = R./burnin_scale;
0715       <span class="keyword">elseif</span> reju/ii &lt; 0.05
0716         <a href="#_sub5" class="code" title="subfunction message(verbosity,level,fmt,varargin)">message</a>(verbosity,2,<span class="string">' (burnin/up) %3.2f'</span>,reju/ii*100)
0717         R = R.*burnin_scale;
0718       <span class="keyword">end</span>
0719     <span class="keyword">else</span>
0720       <a href="#_sub5" class="code" title="subfunction message(verbosity,level,fmt,varargin)">message</a>(verbosity,2,<span class="string">'i:%g adapting (%3.2f,%3.2f,%3.2f)'</span>, <span class="keyword">...</span>
0721               isimu,rej/isimu*100,reju/ii*100,rejl/isimu*100);
0722       [covchain,meanchain,wsum] = <a href="covupd.html" class="code" title="function [xcov,xmean,wsum,R]=covupd(x,w,oldcov,oldmean,oldwsum,oldR)">covupd</a>(chain((lasti+1):chainind,1:npar),1, <span class="keyword">...</span>
0723                                          covchain,meanchain,wsum);
0724       lasti = chainind;
0725 
0726       <span class="comment">%%% ram</span>
0727       <span class="keyword">if</span> doram
0728     uu = u./norm(u);
0729     eta = 1/isimu.^etaparam;
0730     ram = eye(npar) + eta*(min(1,tst)-alphatarget)*(uu'*uu);
0731     upcov = R'*ram*R;
0732       <span class="keyword">else</span>
0733     upcov          = covchain;
0734     upcov(noupd,:) = qcov(noupd,:);
0735     upcov(:,noupd) = qcov(:,noupd);
0736       <span class="keyword">end</span>
0737       <span class="comment">%%%</span>
0738       [Ra,p] = chol(upcov);
0739       <span class="keyword">if</span> p <span class="comment">% singular cmat</span>
0740         <span class="comment">% try to blow it</span>
0741         [Ra,p] = chol(upcov + eye(npar)*qcov_adjust);
0742         <span class="keyword">if</span> p <span class="comment">% stil singular</span>
0743           <a href="#_sub5" class="code" title="subfunction message(verbosity,level,fmt,varargin)">message</a>(verbosity,0,<span class="string">' (cmat singular, no adapt) %3.2f'</span>,reju/ii*100);
0744         <span class="keyword">else</span>
0745           <a href="#_sub5" class="code" title="subfunction message(verbosity,level,fmt,varargin)">message</a>(verbosity,2,<span class="string">' [adjusted cmat]'</span>);
0746           <span class="comment">% scale R</span>
0747           R = Ra * qcov_scale;
0748         <span class="keyword">end</span>
0749       <span class="keyword">else</span>
0750         R = Ra * qcov_scale;
0751       <span class="keyword">end</span>
0752       lasti = isimu;
0753       <span class="keyword">if</span> dodram  <span class="comment">%%%% delayed rejection</span>
0754         RDR{1} = R;
0755         invR{1} = RDR{1}\eye(npar);
0756         <span class="keyword">for</span> k=2:Ntry
0757           RDR{k}  = RDR{k-1}./DR_scale(min(k-1,length(DR_scale)));
0758           invR{k} = invR{k-1}.*DR_scale(min(k-1,length(DR_scale)));
0759         <span class="keyword">end</span>
0760       <span class="keyword">end</span>
0761     <span class="keyword">end</span>
0762     <a href="#_sub5" class="code" title="subfunction message(verbosity,level,fmt,varargin)">message</a>(verbosity,2,<span class="string">'\n'</span>);
0763     reju = 0; ii = 0;
0764   <span class="keyword">end</span>
0765   <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0766   <span class="comment">%%% save chain</span>
0767   saveit = 0;
0768   <span class="keyword">if</span> chainind == savesize &amp;&amp; saveit == 1
0769     <a href="#_sub5" class="code" title="subfunction message(verbosity,level,fmt,varargin)">message</a>(verbosity,2,<span class="string">'saving chains\n'</span>);
0770     <a href="addbin.html" class="code" title="function status=addbin(filename,x)">addbin</a>(chainfile,chain');
0771     <a href="addbin.html" class="code" title="function status=addbin(filename,x)">addbin</a>(sschainfile,sschain');
0772     <span class="keyword">if</span> updatesigma
0773       <a href="addbin.html" class="code" title="function status=addbin(filename,x)">addbin</a>(s2chainfile,s2chain');
0774     <span class="keyword">end</span>
0775     chainind = 0;
0776     <span class="comment">% update covariance</span>
0777     [covchain,meanchain,wsum] = <a href="covupd.html" class="code" title="function [xcov,xmean,wsum,R]=covupd(x,w,oldcov,oldmean,oldwsum,oldR)">covupd</a>(chain((lasti+1):chainind,1:npar),1, <span class="keyword">...</span>
0778                                        covchain,meanchain,wsum);
0779     lasti = 0;
0780   <span class="keyword">end</span>
0781 
0782 <span class="keyword">end</span> <span class="comment">% nsimu</span>
0783 
0784 <span class="comment">% save the rest</span>
0785 <span class="keyword">if</span> chainind&gt;0 &amp;&amp; saveit == 1
0786   <a href="addbin.html" class="code" title="function status=addbin(filename,x)">addbin</a>(chainfile,chain(1:chainind,:)');
0787   <a href="addbin.html" class="code" title="function status=addbin(filename,x)">addbin</a>(sschainfile,sschain(1:chainind,:)');
0788   <span class="keyword">if</span> updatesigma
0789     <a href="addbin.html" class="code" title="function status=addbin(filename,x)">addbin</a>(s2chainfile,s2chain(1:chainind,:)');
0790   <span class="keyword">end</span>
0791   <span class="comment">% update covariance</span>
0792   [covchain,meanchain,wsum] = <a href="covupd.html" class="code" title="function [xcov,xmean,wsum,R]=covupd(x,w,oldcov,oldmean,oldwsum,oldR)">covupd</a>(chain((lasti+1):chainind,1:npar),1, <span class="keyword">...</span>
0793                                      covchain,meanchain,wsum);
0794 <span class="keyword">end</span>
0795 
0796 <span class="comment">%if wbarupd; wbar('close'); end</span>
0797 
0798 value(parind) = oldpar; <span class="comment">% update the initial value to the final value</span>
0799 
0800 <span class="comment">%% build the results structure</span>
0801 <span class="keyword">if</span> nargout&gt;0
0802   results.class = <span class="string">'MCMC'</span>;
0803   results.label = <span class="string">''</span>;<span class="comment">%label;</span>
0804   results.method = method;
0805   results.rejected   = rej/nsimu;
0806   results.ulrejected = rejl/nsimu;
0807   results.R      = R;
0808   results.qcov   = R'*R; <span class="comment">% with scale %  ./ qcov_scale.^2 ;</span>
0809   qcovorig(parind,parind) = results.qcov;
0810   results.qcov2  = qcovorig; <span class="comment">% original size</span>
0811   results.cov    = covchain;
0812   results.mean   = meanchain;
0813   results.names  = names(parind);
0814   results.limits = [low(parind)',upp(parind)'];
0815   results.prior  = [thetamu(parind)',thetasig(parind)'];
0816   results.theta  = value; <span class="comment">% last values</span>
0817   results.parind = parind;
0818   results.local  = local;
0819   results.nbatch = nbatch;
0820   results.N      = N;
0821   <span class="keyword">if</span> updatesigma
0822     results.sigma2 = NaN;
0823     results.S20    = S20;
0824     results.N0     = N0;
0825   <span class="keyword">else</span>
0826     results.sigma2 = sigma2;
0827     results.S20    = NaN;
0828     results.N0     = NaN;
0829   <span class="keyword">end</span>
0830   results.modelfun = modelfun;
0831   results.ssfun    = ssfun;
0832   <span class="comment">%results.priorfun = priorfun;</span>
0833   results.priortype= priortype;
0834   results.priorpars= priorpars;
0835   results.nsimu    = nsimu;
0836   results.adaptint = adaptint;
0837   results.adaptend = lastadapt;
0838   results.adascale = qcov_scale;
0839   results.skip     = 0;<span class="comment">%skip;</span>
0840   <span class="comment">%results.simutime = etime(clock,starttime);</span>
0841   results.ntry     = Ntry;
0842   <span class="keyword">if</span> dostats2
0843     results.accechain = accechain;
0844   <span class="keyword">end</span>
0845   <span class="keyword">if</span> dodram
0846     results.ntry  = Ntry;
0847     results.drscale = DR_scale; <span class="comment">% .^2;</span>
0848     iacce(1) = nsimu-rej-sum(iacce(2:end));
0849     results.iacce = iacce;
0850     results.alpha_count = A_count;
0851     results.RDR = RDR;
0852     <span class="keyword">if</span> dostats2
0853       results.evalchain = evalchain;
0854     <span class="keyword">end</span>
0855   <span class="keyword">end</span>
0856 <span class="keyword">end</span>
0857 
0858 <span class="comment">% check if we need to read the generated chain from binary dump files</span>
0859 <span class="comment">% if saveit == 1 &amp;&amp; savesize &lt; nsimu</span>
0860 <span class="comment">%   if nargout &gt; 1</span>
0861 <span class="comment">%     chain = readbin(chainfile,1,skip);</span>
0862 <span class="comment">%   end</span>
0863 <span class="comment">%   if nargout &gt; 2 &amp;&amp; updatesigma</span>
0864 <span class="comment">%     s2chain = readbin(s2chainfile,1,skip);</span>
0865 <span class="comment">%   end</span>
0866 <span class="comment">%   if nargout &gt; 3</span>
0867 <span class="comment">%     sschain = readbin(sschainfile,1,skip);</span>
0868 <span class="comment">%   end</span>
0869 <span class="comment">% elseif skip&gt;1&amp;&amp;skip&lt;=nsimu</span>
0870 <span class="comment">%   chain = chain(1:skip:end,:);</span>
0871 <span class="comment">%   if updatesigma</span>
0872 <span class="comment">%     s2chain = s2chain(1:skip:end,:);</span>
0873 <span class="comment">%   end</span>
0874 <span class="comment">%   sschain = sschain(1:skip:end,:);</span>
0875 <span class="comment">% end</span>
0876 <span class="comment">% calculate some extra statistics (we need the whole chain to do this)</span>
0877 <span class="keyword">if</span> dostats &amp;&amp; (saveit == 1 || savesize &gt;= nsimu)
0878   results.tau    = <a href="iact.html" class="code" title="function [tau,m] = iact(dati)">iact</a>(chain);
0879   results.geweke = <a href="geweke.html" class="code" title="function [z,p]=geweke(chain,a,b)">geweke</a>(chain);
0880   results.rldiag = <a href="rldiag.html" class="code" title="function y=rldiag(chain,q,r,s,e)">rldiag</a>(chain);
0881   <span class="comment">%% calculate DIC = 2*mean(ss)-ss(mean(chain))</span>
0882   <span class="keyword">if</span> not(savepostinss) <span class="comment">% can not do if this is set</span>
0883     ss = <a href="#_sub1" class="code" title="subfunction ss = sseval(ssfun,ssstyle,theta,parind,value,local,data,problem,modelfun)">sseval</a>(ssfun,ssstyle,meanchain,parind,value,local,data,problem,modelfun);
0884     D = mean(sschain);
0885     results.dic  = 2*D-ss; <span class="comment">% Deviance Information Criterion</span>
0886     results.pdic = D-ss;   <span class="comment">% Effective number of parameters</span>
0887   <span class="keyword">end</span>
0888 <span class="keyword">end</span>
0889 
0890 textProgressBar(<span class="string">'end'</span>,1);
0891 
0892 
0893 
0894 <span class="comment">%% end of main function</span>
0895 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0896 <a name="_sub1" href="#_subfunctions" class="code">function ss = sseval(ssfun,ssstyle,theta,parind,value,local,data,problem,modelfun)</a>
0897 <span class="comment">% evaluate the &quot;sum-of-squares&quot; function</span>
0898 value(parind) = theta;
0899 <span class="comment">%if ssstyle == 1</span>
0900 <span class="comment">%  ss = feval(ssfun,value(:)',data);</span>
0901 <span class="comment">%elseif ssstyle == 4</span>
0902 <span class="comment">%  ss = mcmcssfun(value(:)',data,local,modelfun);</span>
0903 <span class="comment">%else</span>
0904   ss = <a href="reflectivity_fitModel.html" class="code" title="function ss = reflectivity_fitModel(theta,data,problem)">reflectivity_fitModel</a>(value(:)',data,problem);
0905 <span class="comment">%end</span>
0906 <span class="keyword">end</span>
0907 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0908 <a name="_sub2" href="#_subfunctions" class="code">function y=alphafun(varargin)</a>
0909 <span class="comment">% alphafun(x,y1,y2,y3,...)</span>
0910 <span class="comment">% recursive acceptance function for delayed rejection</span>
0911 <span class="comment">% x.p, y1.p, ... contain the parameter value</span>
0912 <span class="comment">% x.ss, y1.ss, ... the sum of squares</span>
0913 <span class="comment">% x.a, y1.a, ... past alpha probabilities</span>
0914 
0915 <span class="comment">% ML 2003</span>
0916 
0917 <span class="comment">%global A_count</span>
0918 A_count = A_count+1;
0919 y = 0;
0920 
0921 stage = nargin - 1; <span class="comment">% The stage we're in, elements in varargin - 1</span>
0922 <span class="comment">% recursively compute past alphas</span>
0923 coder.varsize(<span class="string">'a1'</span>);
0924 coder.varsize(<span class="string">'a2'</span>);
0925 a1 = 1; a2=1;
0926 <span class="keyword">for</span> kk=1:stage-1
0927 <span class="comment">%  a1 = a1*(1-varargin{k+1}.a); % already have these alphas</span>
0928 <span class="comment">% Thanks to E. Prudencio for pointing out an error here</span>
0929   a1 = a1*(1-<a href="#_sub2" class="code" title="subfunction y=alphafun(varargin)">alphafun</a>(varargin{1:(kk+1)}));
0930   a2 = a2*(1-<a href="#_sub2" class="code" title="subfunction y=alphafun(varargin)">alphafun</a>(varargin{(stage+1):-1:(stage+1-kk)}));
0931   <span class="keyword">if</span>  a2==0  <span class="comment">% we will came back with prob 1</span>
0932     y = 0;
0933     <span class="keyword">return</span>
0934   <span class="keyword">end</span>
0935 <span class="keyword">end</span>
0936 y = <a href="#_sub4" class="code" title="subfunction z=lfun(x,y)">lfun</a>(varargin{1},varargin{end});
0937 <span class="keyword">for</span> kk=1:stage
0938   y = y + <a href="#_sub3" class="code" title="subfunction z=qfun(iq,varargin)">qfun</a>(kk,varargin{:});
0939 <span class="keyword">end</span>
0940 y = min(1, exp(y).*a2./a1);
0941 
0942 <span class="keyword">end</span>
0943 <span class="comment">%************************************************************%</span>
0944 <a name="_sub3" href="#_subfunctions" class="code">function z=qfun(iq,varargin)</a>
0945 <span class="comment">% Gaussian n:th stage log proposal ratio</span>
0946 <span class="comment">% log of q_i(y_n,..,y_n-j) / q_i(x,y_1,...,y_j)</span>
0947 
0948 <span class="comment">% ----------------------------------</span>
0949 <span class="comment">% Try to pre set variables to get past 'non constant expression'</span>
0950 <span class="comment">% error in coder.....</span>
0951 coder.varsize(<span class="string">'y1'</span>,[100 100]);
0952 coder.varsize(<span class="string">'y2'</span>,[100 100]);
0953 coder.varsize(<span class="string">'y3'</span>,[100 100]);
0954 coder.varsize(<span class="string">'y4'</span>,[100 100]);
0955 coder.varsize(<span class="string">'z'</span>,[100 100]);
0956 coder.varsize(<span class="string">'iR'</span>,[100,100]);
0957 
0958 y1 = zeros(1,npar);
0959 y2 = zeros(1,npar);
0960 y3 = zeros(1,npar);
0961 y4 = zeros(1,npar);
0962 iR = zeros(npar,npar);
0963 z = 0;
0964 <span class="comment">% -----------------------------</span>
0965 
0966 stage = nargin-1-1;
0967 <span class="keyword">if</span> stage == iq
0968   z = 0;                                <span class="comment">% we are symmetric</span>
0969 <span class="keyword">else</span>
0970   iR = invR{iq};                        <span class="comment">% proposal^(-1/2)</span>
0971   y1 = varargin{1}.p;           <span class="comment">% y1</span>
0972   y2 = varargin{iq+1}.p;        <span class="comment">% y_i</span>
0973   y3 = varargin{stage+1}.p;     <span class="comment">% y_n</span>
0974   y4 = varargin{stage-iq+1}.p;  <span class="comment">% y_(n-i)</span>
0975   z = -0.5*(norm((y4-y3)*iR)^2-norm((y2-y1)*iR)^2);
0976 <span class="keyword">end</span>
0977 
0978 <span class="keyword">end</span>
0979 <span class="comment">%************************************************************%</span>
0980 <a name="_sub4" href="#_subfunctions" class="code">function z=lfun(x,y)</a>
0981 <span class="comment">% log posterior ratio,  log( pi(y)/pi(x) * p(y)/p(x) )</span>
0982 z = -0.5*( sum((y.ss./y.s2-x.ss./x.s2)) + y.pri - x.pri );
0983 <span class="keyword">end</span>
0984 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0985 <a name="_sub5" href="#_subfunctions" class="code">function message(verbosity,level,fmt,varargin)</a>
0986 <span class="keyword">if</span> verbosity&gt;=level
0987   fprintf(fmt,varargin{:})
0988 <span class="keyword">end</span>
0989 <span class="comment">% if verbosity&gt;1&amp;&amp;level&lt;=2&amp;&amp;~strcmp(fmt,'\n')</span>
0990 <span class="comment">%   wbar('message',sprintf(fmt,varargin{:}));</span>
0991 <span class="comment">% end</span>
0992 <span class="keyword">end</span>
0993 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0994 <a name="_sub6" href="#_subfunctions" class="code">function status=wbar(i,nsimu)</a>
0995     
0996     pct = i/nsimu;
0997     textProgressBar(<span class="string">'Bayes:'</span>,pct);
0998     status = 1;
0999     
1000     
1001     
1002 <span class="comment">% %%%% waitbar update</span>
1003 <span class="comment">% persistent hdl t0 tl hmsg</span>
1004 <span class="comment">%</span>
1005 <span class="comment">% status = 1;</span>
1006 <span class="comment">%</span>
1007 <span class="comment">% switch lower(task)</span>
1008 <span class="comment">%  case 'init'</span>
1009 <span class="comment">% %   hdl=waitbar(0,'Generating chain...','CreateCancelBtn','delete(gcbf)');</span>
1010 <span class="comment">% %   set(hdl,'Name','MCMC status');</span>
1011 <span class="comment">%   textProgressBar('Bayes:',0);</span>
1012 <span class="comment">%</span>
1013 <span class="comment">%</span>
1014 <span class="comment">%</span>
1015 <span class="comment">%   t0=clock;</span>
1016 <span class="comment">%   tl=t0;</span>
1017 <span class="comment">% %   hmsg=get(findobj(hdl,'Type','Axes'),'xlabel');</span>
1018 <span class="comment">% %   set(hmsg,'HorizontalAlignment','left');</span>
1019 <span class="comment">% %   set(hmsg,'Position',[0,-1]);</span>
1020 <span class="comment">%  case 'close'</span>
1021 <span class="comment">%   %if ishandle(hdl);delete(hdl);end</span>
1022 <span class="comment">%  case 'message'</span>
1023 <span class="comment">% %   if ishandle(hdl)</span>
1024 <span class="comment">% %     txt = i;</span>
1025 <span class="comment">% %     set(hmsg,'String',txt);</span>
1026 <span class="comment">% %     drawnow</span>
1027 <span class="comment">%   end</span>
1028 <span class="comment">%  otherwise</span>
1029 <span class="comment">% %   if ~ishandle(hdl) % cancel pressed</span>
1030 <span class="comment">% %     status = -1;</span>
1031 <span class="comment">% %     return</span>
1032 <span class="comment">%   end</span>
1033 <span class="comment">%   if (i/50==fix(i/50))</span>
1034 <span class="comment">%     % too slow</span>
1035 <span class="comment">% %  if etime(clock,tl) &gt;= 1 | i &lt; 10 % update every 1 secs</span>
1036 <span class="comment">%     hh=i/nsimu;</span>
1037 <span class="comment">%     %    htitle=get(findobj(hdl,'Type','Axes'),'title');</span>
1038 <span class="comment">%     secs = etime(clock,t0)*(1-hh)/hh;</span>
1039 <span class="comment">%     mins = floor(secs/60);</span>
1040 <span class="comment">%     secs = ceil(secs - 60*mins);</span>
1041 <span class="comment">%     hrs  = floor(mins/60);</span>
1042 <span class="comment">%     mins = mins - hrs*60;</span>
1043 <span class="comment">%     %   if wbarupd</span>
1044 <span class="comment">%     waitbar(hh,hdl, ...</span>
1045 <span class="comment">%             sprintf('Generating chain, eta: %g:%02g:%02g', ...</span>
1046 <span class="comment">%                     hrs,mins,secs));</span>
1047 <span class="comment">% %    set(htitle,'String', ...</span>
1048 <span class="comment">% %               sprintf('Generating chain, eta: %g:%02g:%02g', ...</span>
1049 <span class="comment">% %                       hrs,mins,secs));</span>
1050 <span class="comment">%     drawnow</span>
1051 <span class="comment">%     tl = clock; % last time updated</span>
1052    <span class="comment">%end</span>
1053 <span class="keyword">end</span>
1054 
1055 
1056 
1057 <span class="keyword">end</span>
1058 
1059 <a name="_sub7" href="#_subfunctions" class="code">function out = priorfun(th,mu,sig)</a>
1060   out = sum(((th-mu)./sig).^2);
1061 <span class="keyword">end</span>
1062 
1063 <span class="comment">%%%%% EOF %%%%</span></pre></div>
<hr><address>Generated on Wed 28-Jul-2021 14:15:23 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>