<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of DPPC_gaus_mod_as_custLay_resample</title>
  <meta name="keywords" content="DPPC_gaus_mod_as_custLay_resample">
  <meta name="description" content="ubil_pos ubil_rough ubil_apm ucov lbil_head_pos lbil_rough lbil_apm lcov ox_thick subrough eff_pos">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../../../../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- # RAT --><!-- # targetFunctions --><!-- ../../menu.html common --><!-- ../menu.html matlabEngineCaller_customXY --><!-- menu.html testModel -->
<h1>DPPC_gaus_mod_as_custLay_resample
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../../../up.png"></a></h2>
<div class="box"><strong>ubil_pos ubil_rough ubil_apm ucov lbil_head_pos lbil_rough lbil_apm lcov ox_thick subrough eff_pos</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../../../up.png"></a></h2>
<div class="box"><strong>function [output,subrough] = SAM_supported_bilayer(params,bulk_in,bulk_out,contrast); </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../../../up.png"></a></h2>
<div class="fragment"><pre class="comment">ubil_pos ubil_rough ubil_apm ucov lbil_head_pos lbil_rough lbil_apm lcov ox_thick subrough eff_pos
params = problem.params;
contrast = problem.which_contrast;</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../../../matlabicon.gif)">
<li><a href="../../../../../RAT/targetFunctions/common/makeSLDProfiles/asymconvstep.html" class="code" title="function f = Asymconvstep(x,xw,xcen,s1,s2,h)">asymconvstep</a>	Produces a step function convoluted with differnt error functions</li><li><a href="../../../../../RAT/targetFunctions/common/makeSLDProfiles/asymconvstep.html" class="code" title="function f = Asymconvstep(x,xw,xcen,s1,s2,h)">asymconvstep</a>	Produces a step function convoluted with differnt error functions</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../../../matlabicon.gif)">
<li><a href="testMain.html" class="code" title="">testMain</a>	</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function [x, y] = groupSamples(x,y,tolerance)</a></li><li><a href="#_sub2" class="code">function [tot_sld,vfTot] = new_bil_model(x,params)</a></li><li><a href="#_sub3" class="code">function [tot_sld,vfTot,sam_surf] = new_SAM_model(x,params,subs,alloy,gold,gold_surf)</a></li><li><a href="#_sub4" class="code">function f = gssian(z,Z,N,A)</a></li><li><a href="#_sub5" class="code">function s = sigmoid_up(x,cen,r)</a></li><li><a href="#_sub6" class="code">function s = sigmoid_dn(x,cen,r)</a></li><li><a href="#_sub7" class="code">function f = convstep(x,xw,xcen,s,h)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [output,subrough] = SAM_supported_bilayer(params,bulk_in,bulk_out,contrast);</a>
0002 
0003 <span class="comment">%ubil_pos ubil_rough ubil_apm ucov lbil_head_pos lbil_rough lbil_apm lcov ox_thick subrough eff_pos</span>
0004 <span class="comment">%params = problem.params;</span>
0005 <span class="comment">%contrast = problem.which_contrast;</span>
0006 
0007 sldwat = bulk_out;
0008 subrough = params(1);
0009 <span class="comment">%lbil_head_pos = params(2);</span>
0010 lbil_rough = params(2);
0011 lbil_apm = params(3);
0012 lcov = params(4);
0013 ubil_pos = params(5);
0014 ubil_rough = params(6);
0015 ubil_apm = params(7);
0016 ucov = params(8);
0017 Alloy_thick = params(9);
0018 Alloy_SLD_up = params(10);
0019 Alloy_SLD_down = params(11);
0020 Alloy_rough = params(12);
0021 Gold_thick = params(13);
0022 Gold_rough = params(14);
0023 Gold_sld = params(15);
0024 Zglyc = params(16);
0025 Zpo4 = params(17);
0026 Zchol = params(18);
0027 
0028 
0029 
0030 erf_width_u = 2.73;<span class="comment">%%%%%p;</span>
0031 
0032 
0033 <span class="comment">%erf_width_l = params(13);</span>
0034 
0035 <span class="comment">%need neutron b's</span>
0036 bo = 0.5843e-4;         <span class="comment">%Oxygen</span>
0037 bh = -0.3739e-4;        <span class="comment">%Hydrogen</span>
0038 bd = 0.6671e-4;         <span class="comment">%Deuterium</span>
0039 H2O = (2*bh) + (1*bo);
0040 D2O = (2*bd) + (1*bo);
0041 Vwat = 30.18;
0042 x = 0:500;
0043 <span class="comment">%Calculate mole fraction of D2O from the bulk SLD..</span>
0044 Rho_d2o = 6.35e-6;
0045 Rho_h2o = -0.56e-6;
0046 Rho_this = bulk_out;
0047 d2o_molfr = (Rho_this-Rho_h2o)/(Rho_d2o-Rho_h2o);
0048 
0049 <span class="comment">%Make a substrate bit...</span>
0050 subcen = 0;
0051 subs = <a href="#_sub7" class="code" title="subfunction f = convstep(x,xw,xcen,s,h)">convstep</a>(x,50,0,subrough,1);
0052 subs_edge = 25;
0053 alloy_edge = subs_edge + Alloy_thick;
0054 alloy = <a href="../../../../../RAT/targetFunctions/common/makeSLDProfiles/asymconvstep.html" class="code" title="function f = Asymconvstep(x,xw,xcen,s1,s2,h)">asymconvstep</a>(x,Alloy_thick,(subs_edge + (Alloy_thick/2)),subrough,Alloy_rough,1);
0055 
0056 gold_edge = alloy_edge + Gold_thick;
0057 gold = <a href="../../../../../RAT/targetFunctions/common/makeSLDProfiles/asymconvstep.html" class="code" title="function f = Asymconvstep(x,xw,xcen,s1,s2,h)">asymconvstep</a>(x,Gold_thick,(alloy_edge + (Gold_thick/2)),Alloy_rough,Gold_rough,1);
0058 
0059 <span class="comment">%vfSub = ox + subs;</span>
0060 <span class="comment">%Now for lower layer</span>
0061 p.Roughness = lbil_rough;
0062 <span class="comment">%p.Position = lbil_head_pos + gold_edge;</span>
0063 p.APM =lbil_apm;
0064 p.display = 0;
0065 p.erfwidth = erf_width_u;
0066 p.d2o_molfr = d2o_molfr;
0067 p.coverage = lcov;
0068 p.gold_rough = Gold_rough;
0069 p.Zglyc = Zglyc;
0070 p.Zpo4 = Zpo4;
0071 p.Zchol = Zchol;
0072 <span class="comment">%p.vfSub = vfSub;</span>
0073 [SLDmon,lwat_vf,sam_surf] = <a href="#_sub3" class="code" title="subfunction [tot_sld,vfTot,sam_surf] = new_SAM_model(x,params,subs,alloy,gold,gold_surf)">new_SAM_model</a>(x,p,subs,alloy,gold,gold_edge);
0074 <span class="comment">%lower_pos = p.Position;% + ox_surf;</span>
0075 
0076 <span class="comment">%Parameters for upper bilayer</span>
0077 p.Roughness = ubil_rough;
0078 p.Position = ubil_pos + sam_surf;<span class="comment">%gold_edge;</span>
0079 p.APM = ubil_apm;
0080 p.display = 1;
0081 p.erfwidth = erf_width_u;
0082 <span class="comment">%p.thick = ubil_thick;</span>
0083 p.coverage = ucov;
0084 p.d2o_molfr = d2o_molfr;
0085 p.Zglyc = Zglyc;
0086 p.Zpo4 = Zpo4;
0087 p.Zchol = Zchol;
0088 [SLDbil,uwat_vf] = <a href="#_sub2" class="code" title="subfunction [tot_sld,vfTot] = new_bil_model(x,params)">new_bil_model</a>(x,p);
0089 upper_pos = p.Position;<span class="comment">%</span>
0090 
0091 <span class="comment">%coverage correction.....</span>
0092 <span class="comment">% all_empty = ones(1,length(x));</span>
0093 <span class="comment">% uwat_vf = (ucov * uwat_vf) + ((1 - ucov) * all_empty);</span>
0094 <span class="comment">% upper_bil_sld = (ucov * upper_bil_sld);% + ((1 - ucov) * all_d2o);</span>
0095 
0096 
0097 
0098 <span class="comment">% %coverage correction.....</span>
0099 <span class="comment">% % lwat_vf = (lcov * lwat_vf) + ((1 - lcov) * all_empty);</span>
0100 <span class="comment">% % lower_bil_sld = (lcov * lower_bil_sld);</span>
0101 <span class="comment">%</span>
0102 <span class="comment">% %Splice the two volume fractions</span>
0103 <span class="comment">% midp = floor(((upper_pos - lower_pos)/2) + lower_pos);</span>
0104 <span class="comment">% tot_watvf = [lwat_vf(1:midp),uwat_vf(midp+1:end)];</span>
0105 <span class="comment">%</span>
0106 <span class="comment">% %Calculate the water SLD</span>
0107 <span class="comment">% tot_watvf = tot_watvf - (subs + ox);</span>
0108 <span class="comment">% tot_watnd = tot_watvf / Vwat;</span>
0109 <span class="comment">% watsld = tot_watnd * ((d2o_molfr * D2O) + (1 - d2o_molfr)*H2O);</span>
0110 <span class="comment">% subs_sld = subs .* 2.07e-6;</span>
0111 <span class="comment">%</span>
0112 <span class="comment">% ox_scat_length = (ox_hydr * sldwat) + ((1 - ox_hydr) * 3.41e-6);</span>
0113 <span class="comment">%</span>
0114 <span class="comment">% ox_sld = ox .* ox_scat_length;</span>
0115 <span class="comment">%</span>
0116 <span class="comment">% %Complete SLD of whole thing....</span>
0117 <span class="comment">% tot_sld = upper_bil_sld + lower_bil_sld + watsld + subs_sld + ox_sld;</span>
0118 <span class="comment">% output = [x(:) tot_sld(:)];</span>
0119 
0120 <span class="keyword">switch</span> contrast
0121     <span class="keyword">case</span>{1,3}
0122         AlloySLD = Alloy_SLD_up;
0123     <span class="keyword">otherwise</span>
0124         AlloySLD = Alloy_SLD_down;
0125 <span class="keyword">end</span>
0126 
0127 
0128 SLDalloy = alloy * AlloySLD;
0129 SLDsub = subs * 2.07e-6;
0130 SLDgold = gold * Gold_sld;
0131 
0132 vfWat = ones(1,length(x));
0133 vfWat = vfWat - uwat_vf - lwat_vf - subs - alloy - gold;
0134 <span class="comment">% figure(10)</span>
0135 <span class="comment">% plot(vfWat);</span>
0136 ndWat = vfWat/30.13;
0137 <span class="comment">%sldWat = ndWat * ((d2o_molfr * D2O) + (1 - d2o_molfr)*H2O);</span>
0138 sldWat = vfWat * bulk_out;
0139 
0140 <span class="comment">% figure(2);clf;subplot(3,1,1);</span>
0141 <span class="comment">% hold off</span>
0142 <span class="comment">% plot(x,SLDsub,'k-');</span>
0143 <span class="comment">% hold on</span>
0144 <span class="comment">% plot(x,SLDox,'r-');</span>
0145 <span class="comment">% plot(x,SLDmon,'g-');</span>
0146 <span class="comment">% plot(x,SLDbil,'m-');</span>
0147 <span class="comment">% plot(x,sldWat,'b-');</span>
0148 <span class="comment">%</span>
0149 <span class="comment">% figure(2);subplot(3,1,2);</span>
0150 <span class="comment">% hold off</span>
0151 <span class="comment">% plot(x,ox,'k-');</span>
0152 <span class="comment">% hold on</span>
0153 <span class="comment">% plot(x,subs,'r-');</span>
0154 <span class="comment">% plot(x,lwat_vf,'g-');</span>
0155 <span class="comment">% plot(x,uwat_vf,'m-');</span>
0156 <span class="comment">% plot(x,vfWat,'b-');</span>
0157 
0158 
0159 
0160 
0161 
0162 sldTot = SLDalloy + SLDgold + SLDsub + SLDmon + SLDbil + sldWat;
0163 
0164 
0165 prof = [x(:) sldTot(:)];
0166 
0167 <span class="comment">%debug plot</span>
0168 <span class="comment">% figure (4)</span>
0169 <span class="comment">% clf</span>
0170 <span class="comment">% plot(x,SLDalloy,'r-')</span>
0171 <span class="comment">% hold on</span>
0172 <span class="comment">% plot(x,SLDgold,'m-');</span>
0173 <span class="comment">% plot(x,SLDsub,'b-');</span>
0174 <span class="comment">% plot(x,SLDmon,'c-');</span>
0175 <span class="comment">% plot(x,SLDbil,'y-');</span>
0176 <span class="comment">% plot(x,sldTot,'k-');</span>
0177 <span class="comment">% hold off</span>
0178 
0179 
0180 
0181 <span class="comment">%[prof,subs_surface] = makeSLDProfile(bulk_in(contrast),bulk_out(contrast),Substrate_Roughness,output,size(output,1),1);</span>
0182 <span class="comment">% [xn,yn] = resample_sld(prof,1);</span>
0183 <span class="comment">% [xn,yn] = groupSamples(xn,yn,1e-9);</span>
0184 <span class="comment">% rrr = ones(length(xn),1)*1e-9;</span>
0185 <span class="comment">% output = [xn' yn' rrr];</span>
0186 output = prof;
0187 <span class="keyword">end</span>
0188 
0189 
0190 <span class="comment">%-------------------------------------------------------------------------</span>
0191 <a name="_sub1" href="#_subfunctions" class="code">function [x, y] = groupSamples(x,y,tolerance)</a>
0192 
0193 
0194 debug = 0;
0195 
0196 numberOfLayers = length(x);
0197 count = 1;
0198 newX = [];
0199 newY = [];
0200 
0201 thisLayerx = [x(1)];
0202 thisLayery = [y(1)];
0203 <span class="keyword">try</span>
0204 <span class="keyword">for</span> i = 1:numberOfLayers-1;
0205     <span class="comment">%debug</span>
0206     diff = abs(y(i+1) - y(i));
0207     <span class="keyword">if</span> debug; fprintf(<span class="string">'Diff:- %5.5g  y(i):- %5.3g   pos:-  %5.2f \n'</span>,diff,y(i),i);<span class="keyword">end</span>
0208     <span class="keyword">if</span> diff &lt;= tolerance ;
0209         thisLayerx = [thisLayerx x(i)];
0210         thisLayery = [thisLayery (y(i)+(diff/2))];
0211     <span class="keyword">else</span>
0212         <span class="keyword">if</span> debug; disp(<span class="string">'grouping \n'</span>); <span class="keyword">end</span>
0213         newX = [newX sum(thisLayerx)];
0214         newY = [newY mean(thisLayery)];
0215         thisLayerx = [x(i)];
0216         thisLayery = [y(i)];
0217     <span class="keyword">end</span>
0218 <span class="keyword">end</span>
0219 <span class="keyword">catch</span>
0220     [a,b] = lasterr;
0221     disp(<span class="string">'debug'</span>);
0222 <span class="keyword">end</span>
0223 
0224     
0225 newX = [newX sum(thisLayerx)];
0226 newY = [newY mean(thisLayery)];  
0227     
0228 x = newX;
0229 y = newY;
0230 <span class="keyword">end</span>
0231 
0232 <span class="comment">%******************************************************************</span>
0233 <a name="_sub2" href="#_subfunctions" class="code">function [tot_sld,vfTot] = new_bil_model(x,params)</a>
0234 
0235 <span class="comment">%New version with sigmoidal volume sharing</span>
0236 
0237 <span class="comment">%******************************************************************</span>
0238 <span class="comment">%</span>
0239 <span class="comment">%               Define all the common parameters</span>
0240 <span class="comment">%</span>
0241 <span class="comment">%******************************************************************</span>
0242 
0243 position = params.Position;
0244 Roughness = params.Roughness;
0245 APM = params.APM;               <span class="comment">%Square angstrom;</span>
0246 d2o_molfr = params.d2o_molfr;
0247 displ = params.display;
0248 <span class="comment">%erfwidth = params.erfwidth;</span>
0249 <span class="comment">%thick = params.thick;</span>
0250 coverage = params.coverage;
0251 Zglyc = params.Zglyc;
0252 Zpo4 = params.Zpo4;
0253 Zchol = params.Zchol;
0254 
0255 <span class="comment">%define all the neutron b's.</span>
0256 bc = 0.6646e-4;    <span class="comment">%Carbon</span>
0257 bo = 0.5843e-4;    <span class="comment">%Oxygen</span>
0258 bh = -0.3739e-4;    <span class="comment">%Hydrogen</span>
0259 bp = 0.513e-4;    <span class="comment">%Phosphorus</span>
0260 bn = 0.936e-4;    <span class="comment">%Nitrogen</span>
0261 bd = 0.6671e-4;    <span class="comment">%Deuterium</span>
0262 
0263 <span class="comment">%Work out the total scattering length in each fragment....</span>
0264 COO = (4*bo) + (2*bc);
0265 GLYC = (3*bc) + (5*bh);
0266 CH3 = (1*bc) + (3*bh);              <span class="comment">%Note 2 ch3 groups</span>
0267 PO4 = (1*bp) + (4*bo);
0268 CH2 = (1*bc) + (2*bh);
0269 H2O = (2*bh) + (1*bo);
0270 D2O = (2*bd) + (1*bo);
0271 CHOL = (5*bc) + (13*bh) + (1*bn);
0272 
0273 <span class="comment">%Define volumes....</span>
0274 Vcoo = 39;        <span class="comment">%Carboxy group..</span>
0275 Vglyc = 69;        <span class="comment">%Glycerol group</span>
0276 Vpo4 = 54;        <span class="comment">%Phospho group..</span>
0277 Vchol = 121;    <span class="comment">%Choline group</span>
0278 Vwat = 30.18;    <span class="comment">%Water molecule</span>
0279 Vch3 = 52;      <span class="comment">%Methyl group</span>
0280 Vch2 = 28.1;    <span class="comment">%Methylene group</span>
0281 
0282 chainvol = 32 * Vch2;  <span class="comment">%volume of the alkyl region from Armen et al (ie 26 CH2's of 28Å^3 each)</span>
0283 thickness = chainvol / APM;
0284 
0285 <span class="comment">%and intrinsic roughness'</span>
0286 Ach3 = 2.95;
0287 Acoo = 2.73;
0288 Aglyc = 2.37;
0289 Apo4 = 3.08;
0290 Achol = 3.48;
0291 Awat = 4.63;
0292 
0293 erfwidth = Acoo;
0294 
0295 <span class="comment">%Include a general bilayer roughness</span>
0296 <span class="comment">%Use R = sqrt(i2 + r2)</span>
0297 Roughness = Roughness^2;
0298 Ach3 = sqrt(Ach3^2 + Roughness);
0299 Acoo = sqrt(Acoo^2 + Roughness);
0300 Aglyc = sqrt(Aglyc^2 + Roughness);
0301 Apo4 = sqrt(Apo4^2 + Roughness);
0302 Achol = sqrt(Achol^2 + Roughness);
0303 Awat = sqrt(Awat^2 + Roughness);
0304 erfwidth = sqrt(erfwidth^2 + Roughness);
0305 
0306 <span class="comment">%Each gaussian has a height of 1...</span>
0307 ncoo = 1;    <span class="comment">%i.e there's 1 coo fragment, 1 glyc fragment etc..</span>
0308 nglyc = 1;
0309 npo4 = 1;
0310 nchol = 1;
0311 nch3 = 2;      
0312 
0313 <span class="comment">%***********************************************************%</span>
0314 <span class="comment">%                                                           %</span>
0315 <span class="comment">%               Upper Leaflet Headgroup                     %</span>
0316 <span class="comment">%                                                           %</span>
0317 <span class="comment">%************************************************************</span>
0318 
0319 <span class="comment">%Define centre positions</span>
0320 upper_Zcoo = position + thickness;   
0321 upper_Zglyc = upper_Zcoo + Zglyc;<span class="comment">%2.7;</span>
0322 upper_Zpo4 = upper_Zglyc + Zpo4;
0323 upper_Zchol = upper_Zpo4 + Zchol; 
0324 upper_Zch3 = position;
0325 
0326 <span class="comment">%Make gaussians</span>
0327 upper_nGcoo = <a href="#_sub4" class="code" title="subfunction f = gssian(z,Z,N,A)">gssian</a>(x,upper_Zcoo,ncoo,Acoo);
0328 upper_nGglyc = <a href="#_sub4" class="code" title="subfunction f = gssian(z,Z,N,A)">gssian</a>(x,upper_Zglyc,nglyc,Aglyc);
0329 upper_nGpo4 = <a href="#_sub4" class="code" title="subfunction f = gssian(z,Z,N,A)">gssian</a>(x,upper_Zpo4,npo4,Apo4);
0330 upper_nGchol = <a href="#_sub4" class="code" title="subfunction f = gssian(z,Z,N,A)">gssian</a>(x,upper_Zchol,nchol,Achol);
0331 upper_nGch3 = <a href="#_sub4" class="code" title="subfunction f = gssian(z,Z,N,A)">gssian</a>(x,upper_Zch3,nch3,Ach3);
0332 
0333 <span class="comment">%Gaussians are number of 'molecules' per unit</span>
0334 <span class="comment">%length. To get per unit volume we divide by</span>
0335 <span class="comment">%the APM. Number per unit volume will be</span>
0336 <span class="comment">%the NUMBER DENSITY</span>
0337 upper_nGcoo = upper_nGcoo / APM;
0338 upper_nGglyc = upper_nGglyc / APM;
0339 upper_nGpo4 = upper_nGpo4 / APM;
0340 upper_nGchol = upper_nGchol / APM;
0341 upper_nGch3 = upper_nGch3 / APM;
0342 
0343 <span class="comment">%Now, we need to calculate a volume fraction</span>
0344 <span class="comment">%i.e. a dimensionless quantity between 0 and 1.</span>
0345 <span class="comment">%We just multiply by the component vols</span>
0346 upper_vfGcoo = upper_nGcoo * Vcoo;    <span class="comment">%...these are now dimensionless</span>
0347 upper_vfGglyc = upper_nGglyc * Vglyc; <span class="comment">%since Å3 * Å-3</span>
0348 upper_vfGpo4 = upper_nGpo4 * Vpo4;
0349 upper_vfGchol = upper_nGchol * Vchol;
0350 upper_vfGch3 = upper_nGch3 * Vch3;
0351 
0352 
0353 
0354 <span class="comment">%***********************************************************%</span>
0355 <span class="comment">%                                                           %</span>
0356 <span class="comment">%               Lower Leaflet Headgroup                     %</span>
0357 <span class="comment">%                                                           %</span>
0358 <span class="comment">%************************************************************</span>
0359 <span class="comment">%Define centre positions</span>
0360 lower_Zcoo = position - thickness;   
0361 lower_Zglyc = lower_Zcoo - Zglyc;<span class="comment">%2.7;</span>
0362 lower_Zpo4 = lower_Zglyc - Zpo4;<span class="comment">%4.22;</span>
0363 lower_Zchol = lower_Zpo4 - Zchol;<span class="comment">%5.96;</span>
0364 lower_Zch3 = position;
0365 
0366 <span class="comment">%Make gaussians</span>
0367 lower_nGcoo = <a href="#_sub4" class="code" title="subfunction f = gssian(z,Z,N,A)">gssian</a>(x,lower_Zcoo,ncoo,Acoo);
0368 lower_nGglyc = <a href="#_sub4" class="code" title="subfunction f = gssian(z,Z,N,A)">gssian</a>(x,lower_Zglyc,nglyc,Aglyc);
0369 lower_nGpo4 = <a href="#_sub4" class="code" title="subfunction f = gssian(z,Z,N,A)">gssian</a>(x,lower_Zpo4,npo4,Apo4);
0370 lower_nGchol = <a href="#_sub4" class="code" title="subfunction f = gssian(z,Z,N,A)">gssian</a>(x,lower_Zchol,nchol,Achol);
0371 lower_nGch3 = <a href="#_sub4" class="code" title="subfunction f = gssian(z,Z,N,A)">gssian</a>(x,lower_Zch3,nch3,Ach3);
0372 
0373 <span class="comment">%Gaussians are number of 'molecules' per unit</span>
0374 <span class="comment">%length. To get per unit volume we divide by</span>
0375 <span class="comment">%the APM. Number per unit volume will be</span>
0376 <span class="comment">%the NUMBER DENSITY</span>
0377 lower_nGcoo = lower_nGcoo / APM;
0378 lower_nGglyc = lower_nGglyc / APM;
0379 lower_nGpo4 = lower_nGpo4 / APM;
0380 lower_nGchol = lower_nGchol / APM;
0381 lower_nGch3 = lower_nGch3 / APM;
0382 
0383 <span class="comment">%Now, we need to calculate a volume fraction</span>
0384 <span class="comment">%i.e. a dimensionless quantity between 0 and 1.</span>
0385 <span class="comment">%We just multiply by the component vols</span>
0386 lower_vfGcoo = lower_nGcoo * Vcoo;    <span class="comment">%...these are now dimensionless</span>
0387 lower_vfGglyc = lower_nGglyc * Vglyc; <span class="comment">%since Å3 * Å-3</span>
0388 lower_vfGpo4 = lower_nGpo4 * Vpo4;
0389 lower_vfGchol = lower_nGchol * Vchol;
0390 lower_vfGch3 = lower_nGch3 * Vch3;
0391 
0392 
0393 
0394 <span class="comment">%*******************************************************************</span>
0395 <span class="comment">%</span>
0396 <span class="comment">%               Now deal with the volume calculation</span>
0397 <span class="comment">%</span>
0398 <span class="comment">%*******************************************************************</span>
0399 
0400 <span class="comment">%So to get the free volume fraction, add them all up</span>
0401 <span class="comment">%and its then 1 - total</span>
0402 vfTot = upper_vfGcoo + upper_vfGglyc + upper_vfGpo4 + upper_vfGchol + <span class="keyword">...</span><span class="comment"> </span>
0403 + lower_vfGch3 + lower_vfGcoo + lower_vfGglyc + lower_vfGpo4 + lower_vfGchol + lower_vfGch3;
0404 vf_free = 1 - vfTot;
0405 
0406 <span class="comment">%we need to penalise chi squared for over filling</span>
0407 <span class="comment">% too_much = find(vfTot &gt; 1);</span>
0408 <span class="comment">% toomuch = vfTot(too_much) - 1;</span>
0409 <span class="comment">% add = sum(toomuch);</span>
0410 
0411 <span class="comment">%Split up the volume fraction between the water and CH2's</span>
0412 <span class="comment">%On one side its all water, on the other its all ch2</span>
0413 <span class="comment">%The interface is assumed to be a sigmoidal accross</span>
0414 <span class="comment">%the glyc group for now.</span>
0415 
0416 <span class="comment">%Make the sigmoidals....</span>
0417 <span class="comment">%vf_change_upper = sigmoid(x,upper_Zglyc+erfpos,0,1,(Aglyc/(sqrt(2*pi))));  %note conversion from 1/e roughness</span>
0418 <span class="comment">%vf_change_lower = sigmoid(x,lower_Zglyc-erfpos,1,0,(Aglyc/(sqrt(2*pi))));</span>
0419 
0420 vf_change_upper = <a href="#_sub5" class="code" title="subfunction s = sigmoid_up(x,cen,r)">sigmoid_up</a>(x,upper_Zcoo,erfwidth); 
0421 vf_change_lower = <a href="#_sub6" class="code" title="subfunction s = sigmoid_dn(x,cen,r)">sigmoid_dn</a>(x,lower_Zcoo,erfwidth);
0422 
0423 <span class="comment">%Splice at centre of bilayer....</span>
0424 vf_change_total = vf_change_lower+vf_change_upper;<span class="comment">%[vf_change_lower(1:round(position)) , vf_change_upper(round(position)+1:end)];</span>
0425 
0426 <span class="comment">%So water vfrac is free vol times this...</span>
0427 vfwat = vf_change_total .* vf_free;
0428 
0429 <span class="comment">%..and ch2 is the opposite</span>
0430 vfch2 = (1-vf_change_total) .* vf_free;
0431 
0432 <span class="comment">%Now we need to convert all this into a</span>
0433 <span class="comment">%scattering length density.....</span>
0434 <span class="comment">%For the gaussians, we need to just multiply</span>
0435 <span class="comment">%the number density by sum nb (so units Å-2)....</span>
0436 upper_sld_coo = upper_nGcoo * COO;
0437 upper_sld_glyc = upper_nGglyc * GLYC;
0438 upper_sld_po4 = upper_nGpo4 * PO4;
0439 upper_sld_chol = upper_nGchol * CHOL;
0440 upper_sld_ch3 = upper_nGch3 * CH3;
0441 
0442 lower_sld_coo = lower_nGcoo * COO;
0443 lower_sld_glyc = lower_nGglyc * GLYC;
0444 lower_sld_po4 = lower_nGpo4 * PO4;
0445 lower_sld_chol = lower_nGchol * CHOL;
0446 lower_sld_ch3 = lower_nGch3 * CH3;
0447 
0448 <span class="comment">%For the water and ch2, we have to do a bit more</span>
0449 <span class="comment">%work. We need to convert from volume fraction</span>
0450 <span class="comment">%to number density.</span>
0451 <span class="comment">%i.e. nD(Å-3) = Volume Frac / component vol(Å3)</span>
0452 nd_wat = vfwat / Vwat;  <span class="comment">%assume water occupies 30 Å3</span>
0453 nd_ch2 = vfch2 / Vch2;
0454 
0455 <span class="comment">%The multiply by nb as before</span>
0456 sld_wat = nd_wat * ((d2o_molfr * D2O) + (1 - d2o_molfr)*H2O);
0457 sld_ch2 = nd_ch2 * CH2;
0458 
0459 <span class="comment">%And plot it all out......</span>
0460 displ = 0;
0461 <span class="keyword">switch</span> displ
0462     <span class="keyword">case</span> 1
0463         figure (3)
0464         <span class="comment">%subplot(3,1,contrast);</span>
0465         hold off
0466         plot(x,upper_sld_coo,<span class="string">'g-'</span>);
0467         hold on
0468         plot(x,upper_sld_glyc,<span class="string">'r-'</span>);
0469         plot(x,upper_sld_po4,<span class="string">'k-'</span>);
0470         plot(x,upper_sld_chol,<span class="string">'m-'</span>);
0471         plot(x,upper_sld_ch3 + lower_sld_ch3,<span class="string">'k-'</span>);
0472         plot(x,lower_sld_coo,<span class="string">'g-'</span>);
0473         plot(x,lower_sld_glyc,<span class="string">'r-'</span>);
0474         plot(x,lower_sld_po4,<span class="string">'k-'</span>);
0475         plot(x,lower_sld_chol,<span class="string">'m-'</span>);
0476         
0477         plot(x,sld_wat,<span class="string">'b-'</span>);
0478         plot(x,sld_ch2,<span class="string">'r-'</span>);
0479         ylabel(<span class="string">'Scattering Length Density'</span>)
0480         xlabel(<span class="string">'Distance normal to interface Å'</span>);
0481         axis ([(position - 30) (position + 30) -1e-6 4e-6])
0482 <span class="keyword">end</span>
0483 
0484 <span class="comment">%And D2O comes out to be 6.39e-6. BA DA BOOM! :o)</span>
0485 
0486 vfTot = vfTot + vfch2;
0487 
0488 
0489 tot_sld = lower_sld_coo + lower_sld_glyc + lower_sld_po4 + lower_sld_chol + lower_sld_ch3 + <span class="keyword">...</span>
0490     upper_sld_coo + upper_sld_glyc + upper_sld_po4 + upper_sld_chol + upper_sld_ch3 + sld_ch2;<span class="comment">% + sld_wat;</span>
0491 
0492 <span class="comment">%Try scaling for coverage</span>
0493 vfTot = vfTot * coverage;
0494 tot_sld = tot_sld * coverage;
0495 
0496 
0497 SLD = tot_sld(:);
0498 
0499 
0500 <span class="keyword">end</span>
0501 
0502 
0503 <span class="comment">%******************************************************************</span>
0504 <a name="_sub3" href="#_subfunctions" class="code">function [tot_sld,vfTot,sam_surf] = new_SAM_model(x,params,subs,alloy,gold,gold_surf)</a>
0505 
0506 <span class="comment">%Model for polymerised SAM with Sigmoidal volume sharing</span>
0507 
0508 <span class="comment">%******************************************************************</span>
0509 <span class="comment">%</span>
0510 <span class="comment">%               Define all the common parameters</span>
0511 <span class="comment">%</span>
0512 <span class="comment">%******************************************************************</span>
0513 
0514 <span class="comment">%position = params.Position;</span>
0515 Roughness = params.Roughness;
0516 APM = params.APM;               <span class="comment">%Square angstrom;</span>
0517 d2o_molfr = params.d2o_molfr;
0518 displ = params.display;
0519 erfwidth = params.erfwidth;
0520 coverage = params.coverage;
0521 gold_rough = params.gold_rough;
0522 Zglyc = params.Zglyc;
0523 Zpo4 = params.Zpo4;
0524 Zchol = params.Zchol;
0525 <span class="comment">%vfSub = params.vfSub;</span>
0526 
0527 <span class="comment">%define all the neutron b's.</span>
0528 bc = 0.6646e-4;    <span class="comment">%Carbon</span>
0529 bo = 0.5843e-4;    <span class="comment">%Oxygen</span>
0530 bh = -0.3739e-4;    <span class="comment">%Hydrogen</span>
0531 bp = 0.513e-4;    <span class="comment">%Phosphorus</span>
0532 bn = 0.936e-4;    <span class="comment">%Nitrogen</span>
0533 bd = 0.6671e-4;    <span class="comment">%Deuterium</span>
0534 
0535 <span class="comment">%Work out the total scattering length in each fragment....</span>
0536 COO = (4*bo) + (2*bc);
0537 GLYC = (3*bc) + (5*bh);
0538 CH3 = (1*bc) + (3*bh);              <span class="comment">%Note 2 ch3 groups</span>
0539 PO4 = (1*bp) + (4*bo);
0540 CH2 = (1*bc) + (2*bh);
0541 H2O = (2*bh) + (1*bo);
0542 D2O = (2*bd) + (1*bo);
0543 CHOL = (5*bc) + (13*bh) + (1*bn);
0544 
0545 <span class="comment">%Define volumes....</span>
0546 Vcoo = 39;        <span class="comment">%Carboxy group..</span>
0547 Vglyc = 69;        <span class="comment">%Glycerol group</span>
0548 Vpo4 = 54;        <span class="comment">%Phospho group..</span>
0549 Vchol = 121;    <span class="comment">%Choline group</span>
0550 Vwat = 30.18;    <span class="comment">%Water molecule</span>
0551 Vch3 = 52;      <span class="comment">%Methyl group</span>
0552 Vch2 = 28.1;    <span class="comment">%Methylene group</span>
0553 
0554 <span class="comment">%chainvol = 32 * Vch2;  %volume of the alkyl region from Armen et al (ie 26 CH2's of 28Å^3 each)</span>
0555 
0556 chainVol = (28*Vch2);  
0557 thickness = chainVol/APM;<span class="comment">%position-gold_surf;</span>
0558 position = gold_surf;<span class="comment">%</span>
0559 
0560 <span class="comment">%and intrinsic roughness'</span>
0561 Ach3 = 2.95;
0562 Acoo = 2.73;
0563 Aglyc = 2.37;
0564 Apo4 = 3.08;
0565 Achol = 3.48;
0566 Awat = 4.63;
0567 
0568 <span class="comment">%Include a general bilayer roughness</span>
0569 <span class="comment">%Use R = sqrt(i2 + r2)</span>
0570 Roughness = Roughness^2;
0571 Ach3 = sqrt(Ach3^2 + Roughness);
0572 Acoo = sqrt(Acoo^2 + Roughness);
0573 Aglyc = sqrt(Aglyc^2 + Roughness);
0574 Apo4 = sqrt(Apo4^2 + Roughness);
0575 Achol = sqrt(Achol^2 + Roughness);
0576 Awat = sqrt(Awat^2 + Roughness);
0577 erfwidth = sqrt(erfwidth^2 + Roughness);
0578 
0579 <span class="comment">%Each gaussian has a height of 1...</span>
0580 ncoo = 1;    <span class="comment">%i.e there's 1 coo fragment, 1 glyc fragment etc..</span>
0581 nglyc = 1;
0582 npo4 = 1;
0583 nchol = 1;
0584 nch3 = 1;      
0585 
0586 
0587 
0588 <span class="comment">%***********************************************************%</span>
0589 <span class="comment">%                                                           %</span>
0590 <span class="comment">%               Upper Leaflet Headgroup                     %</span>
0591 <span class="comment">%                                                           %</span>
0592 <span class="comment">%************************************************************</span>
0593 
0594 <span class="comment">%Define centre positions</span>
0595 upper_Zcoo = position + thickness;   
0596 upper_Zglyc = upper_Zcoo + Zglyc;<span class="comment">%2.7;</span>
0597 upper_Zpo4 = upper_Zglyc + Zpo4;
0598 upper_Zchol = upper_Zpo4 + Zchol; 
0599 upper_Zch3 = position;
0600 
0601 <span class="comment">%Make gaussians</span>
0602 upper_nGcoo = <a href="#_sub4" class="code" title="subfunction f = gssian(z,Z,N,A)">gssian</a>(x,upper_Zcoo,ncoo,Acoo);
0603 upper_nGglyc = <a href="#_sub4" class="code" title="subfunction f = gssian(z,Z,N,A)">gssian</a>(x,upper_Zglyc,nglyc,Aglyc);
0604 upper_nGpo4 = <a href="#_sub4" class="code" title="subfunction f = gssian(z,Z,N,A)">gssian</a>(x,upper_Zpo4,npo4,Apo4);
0605 upper_nGchol = <a href="#_sub4" class="code" title="subfunction f = gssian(z,Z,N,A)">gssian</a>(x,upper_Zchol,nchol,Achol);
0606 upper_nGch3 = <a href="#_sub4" class="code" title="subfunction f = gssian(z,Z,N,A)">gssian</a>(x,upper_Zch3,nch3,Ach3);
0607 
0608 <span class="comment">%Gaussians are number of 'molecules' per unit</span>
0609 <span class="comment">%length. To get per unit volume we divide by</span>
0610 <span class="comment">%the APM. Number per unit volume will be</span>
0611 <span class="comment">%the NUMBER DENSITY</span>
0612 upper_nGcoo = upper_nGcoo / APM;
0613 upper_nGglyc = upper_nGglyc / APM;
0614 upper_nGpo4 = upper_nGpo4 / APM;
0615 upper_nGchol = upper_nGchol / APM;
0616 upper_nGch3 = upper_nGch3 / APM;
0617 
0618 <span class="comment">%Now, we need to calculate a volume fraction</span>
0619 <span class="comment">%i.e. a dimensionless quantity between 0 and 1.</span>
0620 <span class="comment">%We just multiply by the component vols</span>
0621 upper_vfGcoo = upper_nGcoo * Vcoo;    <span class="comment">%...these are now dimensionless</span>
0622 upper_vfGglyc = upper_nGglyc * Vglyc; <span class="comment">%since Å3 * Å-3</span>
0623 upper_vfGpo4 = upper_nGpo4 * Vpo4;
0624 upper_vfGchol = upper_nGchol * Vchol;
0625 upper_vfGch3 = upper_nGch3 * Vch3;
0626 
0627 <span class="comment">%*******************************************************************</span>
0628 <span class="comment">%</span>
0629 <span class="comment">%               Now deal with the volume calculation</span>
0630 <span class="comment">%</span>
0631 <span class="comment">%*******************************************************************</span>
0632 
0633 <span class="comment">%So to get the free volume fraction, add them all up</span>
0634 <span class="comment">%and its then 1 - total</span>
0635 vfSubs = subs;<span class="comment">%./max(subs);</span>
0636 vfAlloy = alloy;<span class="comment">%./max(ox);</span>
0637 vfGold = gold;
0638 vfTot = upper_vfGcoo + upper_vfGglyc + upper_vfGpo4 + upper_vfGchol;<span class="comment">% + vfSubs + vfOx;</span>
0639 vf_free = 1 - vfTot;
0640 
0641 <span class="comment">%we need to penalise chi squared for over filling</span>
0642 too_much = find(vfTot &gt; 1);
0643 toomuch = vfTot(too_much) - 1;
0644 add = sum(toomuch);
0645 
0646 <span class="comment">%Split up the volume fraction between the water and CH2's</span>
0647 <span class="comment">%On one side its all water, on the other its all ch2</span>
0648 <span class="comment">%The interface is assumed to be a sigmoidal accross</span>
0649 <span class="comment">%the glyc group for now.</span>
0650 
0651 <span class="comment">%Make the sigmoidals....</span>
0652 vf_change_upper = <a href="#_sub5" class="code" title="subfunction s = sigmoid_up(x,cen,r)">sigmoid_up</a>(x,upper_Zcoo,erfwidth);  <span class="comment">%note conversion from 1/e roughness</span>
0653 
0654 vf_change_lower = <a href="#_sub6" class="code" title="subfunction s = sigmoid_dn(x,cen,r)">sigmoid_dn</a>(x,gold_surf,gold_rough);
0655 
0656 <span class="comment">%splice these at the centre of the SAM.</span>
0657 <span class="comment">%samAlkCen = ((upper_Zcoo - ox_surf)/2) + gold_surf;</span>
0658 
0659 vf_change_total = vf_change_lower + vf_change_upper;<span class="comment">% [vf_change_lower(1:round(samAlkCen)) , vf_change_upper(round(samAlkCen)+1:end)];</span>
0660 
0661 
0662 <span class="comment">%So water vfrac is free vol times this...</span>
0663 vfwat = vf_change_total .* vf_free;
0664 
0665 <span class="comment">%..and ch2 is the opposite</span>
0666 vfch2 = (1-vf_change_total) .* vf_free;
0667 
0668 <span class="comment">%Now we need to convert all this into a</span>
0669 <span class="comment">%scattering length density.....</span>
0670 <span class="comment">%For the gaussians, we need to just multiply</span>
0671 <span class="comment">%the number density by sum nb (so units Å-2)....</span>
0672 upper_sld_coo = upper_nGcoo * COO;
0673 upper_sld_glyc = upper_nGglyc * GLYC;
0674 upper_sld_po4 = upper_nGpo4 * PO4;
0675 upper_sld_chol = upper_nGchol * CHOL;
0676 upper_sld_ch3 = upper_nGch3 * CH3;
0677 
0678 
0679 <span class="comment">%For the water and ch2, we have to do a bit more</span>
0680 <span class="comment">%work. We need to convert from volume fraction</span>
0681 <span class="comment">%to number density.</span>
0682 <span class="comment">%i.e. nD(Å-3) = Volume Frac / component vol(Å3)</span>
0683 <span class="comment">%nd_wat = vfwat / Vwat;  %assume water occupies 30 Å3</span>
0684 nd_ch2 = vfch2 / Vch2;
0685 
0686 <span class="comment">%The multiply by nb as before</span>
0687 <span class="comment">%sld_wat = nd_wat * ((d2o_molfr * D2O) + (1 - d2o_molfr)*H2O);</span>
0688 sld_ch2 = nd_ch2 * CH2;
0689 
0690 <span class="comment">%And plot it all out......</span>
0691 <span class="comment">% switch displ</span>
0692 <span class="comment">%     case 1</span>
0693 <span class="comment">%         figure (3)</span>
0694 <span class="comment">%         %subplot(3,1,contrast);</span>
0695 <span class="comment">%         hold off</span>
0696 <span class="comment">%         plot(x,upper_sld_coo,'g-');</span>
0697 <span class="comment">%         hold on</span>
0698 <span class="comment">%         plot(x,upper_sld_glyc,'r-');</span>
0699 <span class="comment">%         plot(x,upper_sld_po4,'k-');</span>
0700 <span class="comment">%         plot(x,upper_sld_chol,'m-');</span>
0701 <span class="comment">%         plot(x,upper_sld_ch3 + lower_sld_ch3,'k-');</span>
0702 <span class="comment">%         plot(x,lower_sld_coo,'g-');</span>
0703 <span class="comment">%         plot(x,lower_sld_glyc,'r-');</span>
0704 <span class="comment">%         plot(x,lower_sld_po4,'k-');</span>
0705 <span class="comment">%         plot(x,lower_sld_chol,'m-');</span>
0706 <span class="comment">%</span>
0707 <span class="comment">%         plot(x,sld_wat,'b-');</span>
0708 <span class="comment">%         plot(x,sld_ch2,'r-');</span>
0709 <span class="comment">%         ylabel('Scattering Length Density')</span>
0710 <span class="comment">%         xlabel('Distance normal to interface Å');</span>
0711 <span class="comment">%         axis ([(position - 30) (position + 30) -1e-6 4e-6])</span>
0712 <span class="comment">% end</span>
0713 
0714 <span class="comment">%And D2O comes out to be 6.39e-6. BA DA BOOM! :o)</span>
0715 
0716 
0717 vfTot = vfTot + vfch2;
0718 
0719 tot_sld = upper_sld_coo + upper_sld_glyc + upper_sld_po4 + upper_sld_chol + sld_ch2;
0720 
0721 
0722 vfTot = vfTot * coverage;
0723 tot_sld = tot_sld * coverage;
0724 
0725 sam_surf = upper_Zchol;
0726 
0727 
0728 <span class="comment">%vfTot = vfTot - vfSubs - vfOx;</span>
0729 
0730 
0731 
0732 <span class="comment">% SLD = tot_sld(:);</span>
0733 <span class="comment">% vfwat = vfwat + vfSubs + vfOx;</span>
0734 
0735 <span class="keyword">end</span>
0736 
0737 
0738 
0739 
0740 
0741 
0742 <span class="comment">%--------------------------------------------------</span>
0743 <a name="_sub4" href="#_subfunctions" class="code">function f = gssian(z,Z,N,A)</a>
0744 <span class="comment">%f(z) = gaussian(z,Z,N,A)</span>
0745 <span class="comment">%</span>
0746 <span class="comment">%    produces a gaussian at centre Z, of height</span>
0747 <span class="comment">%    N and 1/e half width of A.</span>
0748 
0749 pi = 3.142;
0750 <span class="comment">%a = A*sqrt(2*pi);</span>
0751 f = (N/(A*sqrt(pi)))*exp(-((z-Z).^2)/(A^2));
0752 
0753 <span class="keyword">end</span>
0754 
0755 <span class="comment">%_________________________________________________-</span>
0756 
0757 
0758 <span class="comment">% function y = sigmoid(x,cen,ymin,ymax,width)</span>
0759 <span class="comment">%</span>
0760 <span class="comment">% %y = sigmoid(x,cen,ymin,ymax,width)</span>
0761 <span class="comment">%</span>
0762 <span class="comment">% y = ymin + ((ymax - ymin) ./ (1 + exp(-(x-cen)/width)));</span>
0763 
0764 
0765 <a name="_sub5" href="#_subfunctions" class="code">function s = sigmoid_up(x,cen,r)</a>
0766 b = (x-cen)./((2^0.5)*r);
0767 s =  (0.5*(erf(b)))+0.5;
0768 
0769 <span class="keyword">end</span>
0770 
0771 
0772 <a name="_sub6" href="#_subfunctions" class="code">function s = sigmoid_dn(x,cen,r)</a>
0773 b = (x-cen)./((2^0.5)*r);
0774 s =  (-0.5*(erf(b)))+0.5;
0775 
0776 <span class="keyword">end</span>
0777 
0778 
0779 <a name="_sub7" href="#_subfunctions" class="code">function f = convstep(x,xw,xcen,s,h)</a>
0780 <span class="comment">% Produces a step function convoluted with an error function</span>
0781 <span class="comment">% Convstep [x,xw,xcen,s,h]</span>
0782 <span class="comment">%       x = vector of x values</span>
0783 <span class="comment">%      xw = Width of step function</span>
0784 <span class="comment">%    xcen = Centre point of step function</span>
0785 <span class="comment">%       s = Roughness parameter</span>
0786 <span class="comment">%       h = Height of step function.</span>
0787 
0788 
0789 r = xcen + (xw/2);
0790 l = xcen - (xw/2);
0791 
0792 a = (x-l)./((2^0.5)*s);
0793 b = (x-r)./((2^0.5)*s);
0794 
0795 f = (h/2)*(erf(a)-erf(b));
0796 
0797 <span class="keyword">end</span>
0798</pre></div>
<hr><address>Generated on Sat 20-Feb-2021 16:50:51 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>