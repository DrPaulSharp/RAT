<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of jacobianest</title>
  <meta name="keywords" content="jacobianest">
  <meta name="description" content="gradest: estimate of the Jacobian matrix of a vector valued function of n variables">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- # common --><!-- menu.html jacobianEst -->
<h1>jacobianest
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>gradest: estimate of the Jacobian matrix of a vector valued function of n variables</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function [jac,err] = jacobianest(fun,x0) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> gradest: estimate of the Jacobian matrix of a vector valued function of n variables
 usage: [jac,err] = jacobianest(fun,x0)

 
 arguments: (input)
  fun - (vector valued) analytical function to differentiate.
        fun must be a function of the vector or array x0.
 
  x0  - vector location at which to differentiate fun
        If x0 is an nxm array, then fun is assumed to be
        a function of n*m variables.


 arguments: (output)
  jac - array of first partial derivatives of fun.
        Assuming that x0 is a vector of length p
        and fun returns a vector of length n, then
        jac will be an array of size (n,p)

  err - vector of error estimates corresponding to
        each partial derivative in jac.


 Example: (nonlinear least squares)
  xdata = (0:.1:1)';
  ydata = 1+2*exp(0.75*xdata);
  fun = @(c) ((c(1)+c(2)*exp(c(3)*xdata)) - ydata).^2;

  [jac,err] = jacobianest(fun,[1 1 1])

  jac =
           -2           -2            0
      -2.1012      -2.3222     -0.23222
      -2.2045      -2.6926     -0.53852
      -2.3096      -3.1176     -0.93528
      -2.4158      -3.6039      -1.4416
      -2.5225      -4.1589      -2.0795
       -2.629      -4.7904      -2.8742
      -2.7343      -5.5063      -3.8544
      -2.8374      -6.3147      -5.0518
      -2.9369      -7.2237      -6.5013
      -3.0314      -8.2403      -8.2403

  err =
   5.0134e-15   5.0134e-15            0
   5.0134e-15            0   2.8211e-14
   5.0134e-15   8.6834e-15   1.5804e-14
            0     7.09e-15   3.8227e-13
   5.0134e-15   5.0134e-15   7.5201e-15
   5.0134e-15   1.0027e-14   2.9233e-14
   5.0134e-15            0   6.0585e-13
   5.0134e-15   1.0027e-14   7.2673e-13
   5.0134e-15   1.0027e-14   3.0495e-13
   5.0134e-15   1.0027e-14   3.1707e-14
   5.0134e-15   2.0053e-14   1.4013e-12

  (At [1 2 0.75], jac should be numerically zero)


 See also: derivest, gradient, gradest


 Author: John D'Errico
 e-mail: woodchips@rochester.rr.com
 Release: 1.0
 Release date: 3/6/2007</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
</ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function vec = swapelement(vec,ind,val)</a></li><li><a href="#_sub2" class="code">function [der_romb,errest] = rombextrap(StepRatio,der_init,rombexpon)</a></li><li><a href="#_sub3" class="code">function mat = vec2mat(vec,n,m)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [jac,err] = jacobianest(fun,x0)</a>
0002 <span class="comment">% gradest: estimate of the Jacobian matrix of a vector valued function of n variables</span>
0003 <span class="comment">% usage: [jac,err] = jacobianest(fun,x0)</span>
0004 <span class="comment">%</span>
0005 <span class="comment">%</span>
0006 <span class="comment">% arguments: (input)</span>
0007 <span class="comment">%  fun - (vector valued) analytical function to differentiate.</span>
0008 <span class="comment">%        fun must be a function of the vector or array x0.</span>
0009 <span class="comment">%</span>
0010 <span class="comment">%  x0  - vector location at which to differentiate fun</span>
0011 <span class="comment">%        If x0 is an nxm array, then fun is assumed to be</span>
0012 <span class="comment">%        a function of n*m variables.</span>
0013 <span class="comment">%</span>
0014 <span class="comment">%</span>
0015 <span class="comment">% arguments: (output)</span>
0016 <span class="comment">%  jac - array of first partial derivatives of fun.</span>
0017 <span class="comment">%        Assuming that x0 is a vector of length p</span>
0018 <span class="comment">%        and fun returns a vector of length n, then</span>
0019 <span class="comment">%        jac will be an array of size (n,p)</span>
0020 <span class="comment">%</span>
0021 <span class="comment">%  err - vector of error estimates corresponding to</span>
0022 <span class="comment">%        each partial derivative in jac.</span>
0023 <span class="comment">%</span>
0024 <span class="comment">%</span>
0025 <span class="comment">% Example: (nonlinear least squares)</span>
0026 <span class="comment">%  xdata = (0:.1:1)';</span>
0027 <span class="comment">%  ydata = 1+2*exp(0.75*xdata);</span>
0028 <span class="comment">%  fun = @(c) ((c(1)+c(2)*exp(c(3)*xdata)) - ydata).^2;</span>
0029 <span class="comment">%</span>
0030 <span class="comment">%  [jac,err] = jacobianest(fun,[1 1 1])</span>
0031 <span class="comment">%</span>
0032 <span class="comment">%  jac =</span>
0033 <span class="comment">%           -2           -2            0</span>
0034 <span class="comment">%      -2.1012      -2.3222     -0.23222</span>
0035 <span class="comment">%      -2.2045      -2.6926     -0.53852</span>
0036 <span class="comment">%      -2.3096      -3.1176     -0.93528</span>
0037 <span class="comment">%      -2.4158      -3.6039      -1.4416</span>
0038 <span class="comment">%      -2.5225      -4.1589      -2.0795</span>
0039 <span class="comment">%       -2.629      -4.7904      -2.8742</span>
0040 <span class="comment">%      -2.7343      -5.5063      -3.8544</span>
0041 <span class="comment">%      -2.8374      -6.3147      -5.0518</span>
0042 <span class="comment">%      -2.9369      -7.2237      -6.5013</span>
0043 <span class="comment">%      -3.0314      -8.2403      -8.2403</span>
0044 <span class="comment">%</span>
0045 <span class="comment">%  err =</span>
0046 <span class="comment">%   5.0134e-15   5.0134e-15            0</span>
0047 <span class="comment">%   5.0134e-15            0   2.8211e-14</span>
0048 <span class="comment">%   5.0134e-15   8.6834e-15   1.5804e-14</span>
0049 <span class="comment">%            0     7.09e-15   3.8227e-13</span>
0050 <span class="comment">%   5.0134e-15   5.0134e-15   7.5201e-15</span>
0051 <span class="comment">%   5.0134e-15   1.0027e-14   2.9233e-14</span>
0052 <span class="comment">%   5.0134e-15            0   6.0585e-13</span>
0053 <span class="comment">%   5.0134e-15   1.0027e-14   7.2673e-13</span>
0054 <span class="comment">%   5.0134e-15   1.0027e-14   3.0495e-13</span>
0055 <span class="comment">%   5.0134e-15   1.0027e-14   3.1707e-14</span>
0056 <span class="comment">%   5.0134e-15   2.0053e-14   1.4013e-12</span>
0057 <span class="comment">%</span>
0058 <span class="comment">%  (At [1 2 0.75], jac should be numerically zero)</span>
0059 <span class="comment">%</span>
0060 <span class="comment">%</span>
0061 <span class="comment">% See also: derivest, gradient, gradest</span>
0062 <span class="comment">%</span>
0063 <span class="comment">%</span>
0064 <span class="comment">% Author: John D'Errico</span>
0065 <span class="comment">% e-mail: woodchips@rochester.rr.com</span>
0066 <span class="comment">% Release: 1.0</span>
0067 <span class="comment">% Release date: 3/6/2007</span>
0068 
0069 <span class="comment">% get the length of x0 for the size of jac</span>
0070 nx = numel(x0);
0071 
0072 MaxStep = 100;
0073 StepRatio = 2;
0074 
0075 <span class="comment">% get fun at the center point</span>
0076 f0 = fun(x0);
0077 f0 = f0(:);
0078 n = length(f0);
0079 <span class="keyword">if</span> n==0
0080   <span class="comment">% empty begets empty</span>
0081   jac = zeros(0,nx);
0082   err = jac;
0083   <span class="keyword">return</span>
0084 <span class="keyword">end</span>
0085 
0086 relativedelta = MaxStep*StepRatio .^(0:-1:-25);
0087 nsteps = length(relativedelta);
0088 
0089 <span class="comment">% total number of derivatives we will need to take</span>
0090 jac = zeros(n,nx);
0091 err = jac;
0092 <span class="keyword">for</span> i = 1:nx
0093   x0_i = x0(i);
0094   <span class="keyword">if</span> x0_i ~= 0
0095     delta = x0_i*relativedelta;
0096   <span class="keyword">else</span>
0097     delta = relativedelta;
0098   <span class="keyword">end</span>
0099   
0100   <span class="comment">% evaluate at each step, centered around x0_i</span>
0101   <span class="comment">% difference to give a second order estimate</span>
0102   fdel = zeros(n,nsteps);
0103   <span class="keyword">for</span> j = 1:nsteps
0104     fdif = fun(<a href="#_sub1" class="code" title="subfunction vec = swapelement(vec,ind,val)">swapelement</a>(x0,i,x0_i + delta(j))) - <span class="keyword">...</span>
0105       fun(<a href="#_sub1" class="code" title="subfunction vec = swapelement(vec,ind,val)">swapelement</a>(x0,i,x0_i - delta(j)));
0106     
0107     fdel(:,j) = fdif(:);
0108   <span class="keyword">end</span>
0109   
0110   <span class="comment">% these are pure second order estimates of the</span>
0111   <span class="comment">% first derivative, for each trial delta.</span>
0112   derest = fdel.*repmat(0.5 ./ delta,n,1);
0113   
0114   <span class="comment">% The error term on these estimates has a second order</span>
0115   <span class="comment">% component, but also some 4th and 6th order terms in it.</span>
0116   <span class="comment">% Use Romberg exrapolation to improve the estimates to</span>
0117   <span class="comment">% 6th order, as well as to provide the error estimate.</span>
0118   
0119   <span class="comment">% loop here, as rombextrap coupled with the trimming</span>
0120   <span class="comment">% will get complicated otherwise.</span>
0121   <span class="keyword">for</span> j = 1:n
0122     [der_romb,errest] = <a href="#_sub2" class="code" title="subfunction [der_romb,errest] = rombextrap(StepRatio,der_init,rombexpon)">rombextrap</a>(StepRatio,derest(j,:),[2 4]);
0123     
0124     <span class="comment">% trim off 3 estimates at each end of the scale</span>
0125     nest = length(der_romb);
0126     trim = [1:3, nest+(-2:0)];
0127     [der_romb,tags] = sort(der_romb);
0128     der_romb(trim) = [];
0129     tags(trim) = [];
0130     
0131     errest = errest(tags);
0132     
0133     <span class="comment">% now pick the estimate with the lowest predicted error</span>
0134     [err(j,i),ind] = min(errest);
0135     jac(j,i) = der_romb(ind);
0136   <span class="keyword">end</span>
0137 <span class="keyword">end</span>
0138 
0139 <span class="keyword">end</span> <span class="comment">% mainline function end</span>
0140 
0141 <span class="comment">% =======================================</span>
0142 <span class="comment">%      sub-functions</span>
0143 <span class="comment">% =======================================</span>
0144 <a name="_sub1" href="#_subfunctions" class="code">function vec = swapelement(vec,ind,val)</a>
0145 <span class="comment">% swaps val as element ind, into the vector vec</span>
0146 vec(ind) = val;
0147 
0148 <span class="keyword">end</span> <span class="comment">% sub-function end</span>
0149 
0150 <span class="comment">% ============================================</span>
0151 <span class="comment">% subfunction - romberg extrapolation</span>
0152 <span class="comment">% ============================================</span>
0153 <a name="_sub2" href="#_subfunctions" class="code">function [der_romb,errest] = rombextrap(StepRatio,der_init,rombexpon)</a>
0154 <span class="comment">% do romberg extrapolation for each estimate</span>
0155 <span class="comment">%</span>
0156 <span class="comment">%  StepRatio - Ratio decrease in step</span>
0157 <span class="comment">%  der_init - initial derivative estimates</span>
0158 <span class="comment">%  rombexpon - higher order terms to cancel using the romberg step</span>
0159 <span class="comment">%</span>
0160 <span class="comment">%  der_romb - derivative estimates returned</span>
0161 <span class="comment">%  errest - error estimates</span>
0162 <span class="comment">%  amp - noise amplification factor due to the romberg step</span>
0163 
0164 srinv = 1/StepRatio;
0165 
0166 <span class="comment">% do nothing if no romberg terms</span>
0167 nexpon = length(rombexpon);
0168 rmat = ones(nexpon+2,nexpon+1);
0169 <span class="comment">% two romberg terms</span>
0170 rmat(2,2:3) = srinv.^rombexpon;
0171 rmat(3,2:3) = srinv.^(2*rombexpon);
0172 rmat(4,2:3) = srinv.^(3*rombexpon);
0173 
0174 <span class="comment">% qr factorization used for the extrapolation as well</span>
0175 <span class="comment">% as the uncertainty estimates</span>
0176 [qromb,rromb] = qr(rmat,0);
0177 
0178 <span class="comment">% the noise amplification is further amplified by the Romberg step.</span>
0179 <span class="comment">% amp = cond(rromb);</span>
0180 
0181 <span class="comment">% this does the extrapolation to a zero step size.</span>
0182 ne = length(der_init);
0183 rhs = <a href="#_sub3" class="code" title="subfunction mat = vec2mat(vec,n,m)">vec2mat</a>(der_init,nexpon+2,ne - (nexpon+2));
0184 rombcoefs = rromb\(qromb'*rhs);
0185 der_romb = rombcoefs(1,:)';
0186 
0187 <span class="comment">% uncertainty estimate of derivative prediction</span>
0188 s = sqrt(sum((rhs - rmat*rombcoefs).^2,1));
0189 rinv = rromb\eye(nexpon+1);
0190 cov1 = sum(rinv.^2,2); <span class="comment">% 1 spare dof</span>
0191 errest = s'*12.7062047361747*sqrt(cov1(1));
0192 
0193 <span class="keyword">end</span> <span class="comment">% rombextrap</span>
0194 
0195 
0196 <span class="comment">% ============================================</span>
0197 <span class="comment">% subfunction - vec2mat</span>
0198 <span class="comment">% ============================================</span>
0199 <a name="_sub3" href="#_subfunctions" class="code">function mat = vec2mat(vec,n,m)</a>
0200 <span class="comment">% forms the matrix M, such that M(i,j) = vec(i+j-1)</span>
0201 [i,j] = ndgrid(1:n,0:m-1);
0202 ind = i+j;
0203 mat = vec(ind);
0204 <span class="keyword">if</span> n==1
0205   mat = mat';
0206 <span class="keyword">end</span>
0207 
0208 <span class="keyword">end</span> <span class="comment">% vec2mat</span>
0209 
0210</pre></div>
<hr><address>Generated on Fri 25-Jun-2021 10:22:15 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>